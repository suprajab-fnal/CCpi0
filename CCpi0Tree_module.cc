////////////////////////////////////////////////////////////////////////
// Class:       CCpi0Tree
// Module Type: analyzer
// File:        CCpi0Tree_module.cc
// Script to check CC inclusive filter for the CC pi0 analysis
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Persistency/Common/Wrapper.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Persistency/Common/FindOne.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "canvas/Persistency/Common/Ptr.h"

#include "lardataobj/MCBase/MCShower.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/PFParticleMetadata.h"
#include "lardataobj/RecoBase/MCSFitResult.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"

#include "larreco/RecoAlg/TrackMomentumCalculator.h"
#include "larreco/RecoAlg/EMShowerAlg.h"

#include "larevt/SpaceChargeServices/SpaceChargeService.h"

#include "larsim/MCCheater/ParticleInventoryService.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/Simulation/LArG4Parameters.h"

#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/Utilities/GeometryUtilities.h"
#include "lardata/Utilities/UtilException.h"
#include "lardata/ArtDataHelper/MVAReader.h"

#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/GTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"

#include "larcore/Geometry/Geometry.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larcoreobj/SummaryData/POTSummary.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcorealg/Geometry/CryostatGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "larcorealg/Geometry/TPCGeo.h"

#include "ubobj/ubobj/UBXSec/SelectionResult.h"
#include "ubobj/ubobj/UBXSec/TPCObject.h"

#include "time.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <vector>
#include <climits>

#include "TGeoMatrix.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TFile.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "TTree.h"
#include "TH1F.h"
#include "TH1D.h"
#include "TH1I.h"
#include "TH2F.h"
#include "TF1.h"
#include "TEfficiency.h"
#include "TGraphAsymmErrors.h"
#include <TMath.h>
#include <TLorentzVector.h>

using namespace std;

class CCpi0Tree;

class CCpi0Tree : public art::EDAnalyzer {
public:
  explicit CCpi0Tree(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  // Plugins should not be copied or assigned.
  CCpi0Tree(CCpi0Tree const &) = delete;
  CCpi0Tree(CCpi0Tree &&) = delete;
  CCpi0Tree & operator = (CCpi0Tree const &) = delete;
  CCpi0Tree & operator = (CCpi0Tree &&) = delete;
  
 // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob() override;
  void endSubRun(art::SubRun const & sr) override;
  void endJob() override;
  
  //general
  bool inFV(double x, double y, double z);
  double getPhi(double px, double py, double pz);
  double getFlashChi2Weight(double chi2);
  double getNewFlashChi2Weight(double chi2);
  double getNewFlashChi2WeightRun2(double chi2);
  double getNewFlashChi2WeightRun3(double chi2);
  int bestPlane(std::vector<art::Ptr<recob::Hit>> hits);
  
  //calorimetry
  float showerEnergy(int plane, std::vector<art::Ptr<recob::Hit>> hits);
  double QtoEConversion(double Q);
  double getMedian(std::vector<double> thisvector);
  double getAmalgamateddEdx(double angle_wrt_plane0, double angle_wrt_plane1, double angle_wrt_plane2, double median_plane0, double median_plane1, double median_plane2, int plane0_nhits, int plane1_nhits, int plane2_nhits);
  double degToRad(double deg);
  double radToDeg(double rad);
  double cosineToDeg(double cosine);
  double getAnglewrtWires(TVector3 shower_dir,int plane);
  std::vector<double> CalcdQdxShower(const art::Ptr<recob::Shower>& shower, const art::Ptr<recob::Cluster>& thiscluster, std::vector<art::Ptr<recob::Hit>> hits,  int plane, float trunklength);
  double GetQHit(art::Ptr<recob::Hit> thishitptr, int plane);
  double getPitch(TVector3 shower_dir, int plane);
  TVector3 getWireVec(int plane);
  double getCoswrtWires(TVector3 shower_dir, TVector3 wire_dir);
  std::vector<std::vector<double>> buildRectangle(std::vector<double> cluster_start, std::vector<double> cluster_axis, double width, double length);
  bool isInsidev2(std::vector<double> thishit_pos, std::vector<std::vector<double >> rectangle, float trunklength);
  double areaTriangle(double x1, double y1, double x2, double y2, double x3, double y3);
  float XOffset(float t);
  void TrackFitdEdx(std::vector<art::Ptr<anab::Calorimetry>> trackcaloobjects, float trunklength, float &dedxU, float &dedxV, float &dedxY);
  void getdEdx(art::Event const & e, art::InputTag calo_tag, art::InputTag shower_tag, art::InputTag pfp_tag, art::InputTag track_tag, art::InputTag trackfitter_tag, art::InputTag cluster_tag, art::Ptr<recob::Shower> shower, std::vector<art::Ptr<recob::PFParticle>> nuPFParticles, std::vector<art::Ptr<recob::Track>> TrackFitterVector, int trackID, float trunklength, float trunkwidth, double& dedx0, double& dedx1, double& dedx2, double& amalgdedx);
  
  //truth information
  double getPurity(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, int Gamma1_id, int Gamma2_id, art::InputTag hitparticleassns_tag, int plane);
  double getComplete(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, int Gamma1_id, int Gamma2_id, art::InputTag hitparticleassns_tag, int plane);
  double getShowerBias(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, float Gamma1_E, float Gamma2_E, float energy, art::InputTag hitparticleassns_tag, int plane);
  double getTrueTrackComposition(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> track_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, art::InputTag hitparticleassns_tag, int plane);
  double getTrueComposition(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, art::InputTag hitparticleassns_tag, int plane);
  void getKids(std::vector<art::Ptr<simb::MCParticle>> all_mcpart_vector, int mcpart_id, std::vector<art::Ptr<simb::MCParticle>>& mcpart_kids);
  void getOverlayEnergy(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane, float& overlay_energy);
  void getTrueParticle(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane, int& shower_mcparticleid, float& shower_mcenergy);
  int getTrueParticleID(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane);
  
  //pi0
  double conversionDistance(art::Ptr<recob::Shower> shower, float vx, float vy, float vz);
  double radialAngle(art::Ptr<recob::Shower> shower, float vx, float vy, float vz);
  double trackRadialAngle(art::Ptr<recob::Track> track, float vx, float vy, float vz);
  double angleBetweenTwoShowers(art::Ptr<recob::Shower> shower1, art::Ptr<recob::Shower> shower2);
  double pi0Mass(double energy1, double energy2, double angle);
  double pi0Momentum(double mass, double energy1, double energy2, double angle);
  double Altpi0Momentum(double energy1, double energy2, double angle);
  double pi0Angle(double p, double energy1, double energy2, art::Ptr<recob::Shower> gamma1, art::Ptr<recob::Shower> gamma2);
  double pi0Phi(double energy1, double energy2, art::Ptr<recob::Shower> gamma1, art::Ptr<recob::Shower> gamma2);
  double pi0MomentumBias(double true_p, double reco_p);
  double pi0AngleBias(double true_px, double true_py, double true_pz, double true_p, double reco_p, double reco_energy1, double reco_energy2, art::Ptr<recob::Shower> reco_gamma1, art::Ptr<recob::Shower> reco_gamma2);
  double muonMomentumBias(double true_p, double reco_p);
  double muonAngleBias(double vx, double vy, double vz, double true_px, double true_py, double true_pz, double true_p, double reco_p, art::Ptr<recob::Track> muon);
  double GammaAngleBias(int mcparticleid, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, double Gamma1_E, double Gamma2_E, double Gamma1_DirX, double Gamma1_DirY, double Gamma1_DirZ, double Gamma2_DirX, double Gamma2_DirY, double Gamma2_DirZ, double reco_energy, art::Ptr<recob::Shower> reco_gamma);
  
private:

  art::InputTag fEventWeightTag;
  art::InputTag fMCTruthTag;
  art::InputTag fGTruthTag;
  art::InputTag fMCParticleTag;
  art::InputTag fTrackTag;
  art::InputTag fTrackFitterTag;
  art::InputTag fCaloTag;
  art::InputTag fShowerTag;
  art::InputTag fClusterTag;
  art::InputTag fPFParticleTag;
  art::InputTag fMCShowerTag;
  art::InputTag fHitTag;
  art::InputTag fOpFlashTag;
  art::InputTag fHitPartAssnTag;
  art::InputTag fPFParticleMetadataTag;
  art::InputTag fMCSFitResultTag;
     
  bool fIsMC;
  bool fIsDirt;
  
  //TREES
  TTree* _tree;
  int _run;
  int _subRun;
  int _event;
  double _pot;
  
  TTree* _eventtree;

  //Cross section systematics
  std::vector<float> _f_All_Genie_Weights;
  std::vector<float> _f_RPA_CCQE_Genie_Weights;
  std::vector<float> _f_XSecShape_CCMEC_Genie_Weights;
  std::vector<float> _f_AxFFCCQEshape_Genie_Weights;
  std::vector<float> _f_VecFFCCQEshape_Genie_Weights;
  std::vector<float> _f_DecayAngMEC_Genie_Weights;
  std::vector<float> _f_Theta_Delta2Npi_Genie_Weights;
  
  //Flux systematics
  std::vector<float> _f_expskin_FluxUnisim_Weights;
  std::vector<float> _f_horncurrent_FluxUnisim_Weights;
  std::vector<float> _f_kminus_PrimaryHadronNormalization_Weights;
  std::vector<float> _f_kplus_PrimaryHadronFeynmanScaling_Weights;
  std::vector<float> _f_kzero_PrimaryHadronSanfordWang_Weights;
  std::vector<float> _f_nucleoninexsec_FluxUnisim_Weights;
  std::vector<float> _f_nucleonqexsec_FluxUnisim_Weights;
  std::vector<float> _f_nucleontotxsec_FluxUnisim_Weights;
  std::vector<float> _f_piminus_PrimaryHadronSWCentralSplineVariation_Weights;
  std::vector<float> _f_pioninexsec_FluxUnisim_Weights;
  std::vector<float> _f_pionqexsec_FluxUnisim_Weights;
  std::vector<float> _f_piontotxsec_FluxUnisim_Weights;
  std::vector<float> _f_piplus_PrimaryHadronSWCentralSplineVariation_Weights;

  //Event information
  int _fRun;
  int _fSubRun;
  int _fEvent;
  float _fCVWeight;
  int _fNuCCNC;
  int _fNuMode;
  float _fNuEnergy;
  float _fNuVtxX;
  float _fNuVtxY;
  float _fNuVtxZ;
  int _fNuPDG;
  int _fNuInFV;
  int _fResNum;

  int _fLepPdg;
  float _fLepP;
  float _fLepPx;
  float _fLepPy;
  float _fLepPz;
  float _fLepCosTheta;
  float _fLepPhi; 

  float _fPi0E;
  float _fPi0P;
  float _fPi0M;
  float _fPi0Px;
  float _fPi0Py;
  float _fPi0Pz;
  float _fPi0CosTheta;
  float _fPi0Phi;

  int _fNpi0;
  int _fNmuon;
  int _fNpiplus;
  int _fNproton;
  int _fNneutron;

  int _fGamma1_id;
  int _fGamma2_id;
  float _fGamma1_E;
  float _fGamma2_E;
  float _fGamma12_CosTheta;
  float _fGamma12_Angle;
  
  float _fGamma1_DirX;
  float _fGamma1_DirY;
  float _fGamma1_DirZ;
  
  float _fGamma2_DirX;
  float _fGamma2_DirY;
  float _fGamma2_DirZ;      
  
  int _fGamma1E1_id;
  int _fGamma1E2_id;
  int _fGamma2E1_id;
  int _fGamma2E2_id;

  std::vector<float> _fSignalDefPi0Momentum;
  std::vector<float> _fSignalDefPiPlusMomentum;
  std::vector<float> _fSignalDefMuMomentum;

  //Truth level object information
  int _fCandidateMuonComposition;
  float _fCandidateMuonMCSMomentumBias;
  float _fCandidateMuonRangeMomentumBias;
  float _fCandidateMuonMomentumBias;
  float _fCandidateMuonAngleBiasCosine;
  float _fCandidateMuonAngleBiasDegrees;

  float _fCandidatePi0MomentumBias;
  float _fCandidatePi0AngleBiasCosine;
  float _fCandidatePi0AngleBiasDegrees;
  
  int _fCandidateLeadComposition;
  float _fCandidateLeadPurity;
  float _fCandidateLeadCompleteness;
  float _fCandidateLeadEnergyBias;
  float _fCandidateLeadAngleBiasCosine;
  float _fCandidateLeadAngleBiasDegrees;
  
  int _fCandidateSubleadComposition;
  float _fCandidateSubleadPurity;
  float _fCandidateSubleadCompleteness;
  float _fCandidateSubleadEnergyBias;
  float _fCandidateSubleadAngleBiasCosine;
  float _fCandidateSubleadAngleBiasDegrees;

  std::vector<int> _fTrackComposition;
  std::vector<int> _fShowerComposition;
  std::vector<float> _fShowerPurity0;
  std::vector<float> _fShowerPurity1;
  std::vector<float> _fShowerPurity2;
  std::vector<float> _fShowerPurity3;
  std::vector<float> _fShowerCompleteness0;
  std::vector<float> _fShowerCompleteness1;
  std::vector<float> _fShowerCompleteness2;
  std::vector<float> _fShowerCompleteness3;
  std::vector<float> _fShowerEnergyBias0;
  std::vector<float> _fShowerEnergyBias1;
  std::vector<float> _fShowerEnergyBias2;
  std::vector<float> _fShowerEnergyBias3;

  //Count reconstructed objects
  int _fNTracks;
  int _fNShowers;
  int _fNHitsU;
  int _fNHitsV;
  int _fNHitsY;

  //Flash information
  float _fFlashChi2;
  float _fFlashChi2Weight;
  float _fFlashNewChi2Weight;
  double _fFlashTime;
  double _fFlashTimeWidth;
  double _fFlashAbsTime;
  double _fFlashTotalPE;
  double _fFlashYCenter;
  double _fFlashYWidth;
  double _fFlashZCenter;
  double _fFlashZWidth;
  
  //Candidate track & vertex
  float _fCandidateVertexX;
  float _fCandidateVertexY;
  float _fCandidateVertexZ;
  
  int _fCandidateMuonBestPlane;
  int _fCandidateMuonIsContained;
  float _fCandidateMuonDist3d;
  float _fCandidateMuonAng3d;
  float _fCandidateMuonPID;
  float _fCandidateMuonStartX;
  float _fCandidateMuonStartY;
  float _fCandidateMuonStartZ;
  float _fCandidateMuonEndX;
  float _fCandidateMuonEndY;
  float _fCandidateMuonEndZ;
  float _fCandidateMuonMomentum;
  float _fCandidateMuonMCSMomentum;
  float _fCandidateMuonRangeMomentum;
  float _fCandidateMuonLength;
  float _fCandidateMuonCostheta;
  float _fCandidateMuonPhi;
   
  //Candidate pi0
  float _fCandidatePi0Momentum;
  float _fCandidatePi0Costheta;
  float _fCandidatePi0Phi;
  std::vector<float> _fCandidatePi0Mass;
  float _fCandidatePi0Energy;
  float _fCandidatePi0Angle12;
 
  //Candidate photons
  int _fCandidateLeadBestPlane;
  float _fCandidateLeadScore;
  float _fCandidateLeadLength;
  float _fCandidateLeadOpenAngle;
  float _fCandidateLeadDirX;
  float _fCandidateLeadDirY;
  float _fCandidateLeadDirZ;
  float _fCandidateLeadCostheta;
  float _fCandidateLeadPhi;
  float _fCandidateLeadThetaXZ;
  float _fCandidateLeadThetaYZ;
  float _fCandidateLeadDist3d;
  float _fCandidateLeadAng3d;
  float _fCandidateLeadStartX;
  float _fCandidateLeadStartY;
  float _fCandidateLeadStartZ;
  float _fCandidateLeadEnergy;
  float _fCandidateLeaddEdx0;
  float _fCandidateLeaddEdx1;
  float _fCandidateLeaddEdx2;
  float _fCandidateLeaddEdx3;
  
  int _fCandidateSubleadBestPlane;
  float _fCandidateSubleadScore;
  float _fCandidateSubleadLength;
  float _fCandidateSubleadOpenAngle;
  float _fCandidateSubleadDirX;
  float _fCandidateSubleadDirY;
  float _fCandidateSubleadDirZ;
  float _fCandidateSubleadCostheta;
  float _fCandidateSubleadPhi;
  float _fCandidateSubleadThetaXZ;
  float _fCandidateSubleadThetaYZ;
  float _fCandidateSubleadDist3d;
  float _fCandidateSubleadAng3d;
  float _fCandidateSubleadStartX;
  float _fCandidateSubleadStartY;
  float _fCandidateSubleadStartZ;
  float _fCandidateSubleadEnergy;
  float _fCandidateSubleaddEdx0;
  float _fCandidateSubleaddEdx1;
  float _fCandidateSubleaddEdx2;
  float _fCandidateSubleaddEdx3;

  //All tracks
  std::vector<int> _fTrackTrueComposition0;
  std::vector<int> _fTrackTrueComposition1;
  std::vector<int> _fTrackTrueComposition2;
  std::vector<int> _fTrackTrueComposition;
  std::vector<int> _fTrackBestPlane;
  std::vector<int> _fTrackIsContained;
  std::vector<float> _fTrackDist3d;
  std::vector<float> _fTrackAng3d;
  std::vector<float> _fTrackPID;
  std::vector<float> _fTrackStartX;
  std::vector<float> _fTrackStartY;
  std::vector<float> _fTrackStartZ;
  std::vector<float> _fTrackEndX;
  std::vector<float> _fTrackEndY;
  std::vector<float> _fTrackEndZ;
  std::vector<float> _fTrackMomentum;
  std::vector<float> _fTrackLength;
  std::vector<float> _fTrackCostheta;
  std::vector<float> _fTrackPhi;

  //All showers
  std::vector<int> _fShowerBestPlane;
  std::vector<float> _fTrackShowerScore;
  std::vector<float> _fShowerLength;
  std::vector<float> _fShowerOpenAngle;
  std::vector<float> _fShowerDirX;
  std::vector<float> _fShowerDirY;
  std::vector<float> _fShowerDirZ;
  std::vector<float> _fShowerCostheta;
  std::vector<float> _fShowerPhi;
  std::vector<float> _fShowerThetaXZ;
  std::vector<float> _fShowerThetaYZ;
  std::vector<float> _fShowerDist3d;
  std::vector<float> _fShowerAng3d;
  std::vector<float> _fShowerStartX;
  std::vector<float> _fShowerStartY;
  std::vector<float> _fShowerStartZ;
  std::vector<float> _fShowerEnergy0;
  std::vector<float> _fShowerEnergy1;
  std::vector<float> _fShowerEnergy2;
  std::vector<float> _fShowerEnergy3;
  std::vector<float> _fShowerdEdx0;
  std::vector<float> _fShowerdEdx1;
  std::vector<float> _fShowerdEdx2;
  std::vector<float> _fShowerdEdx3;
 
  //Cut variables
  int _fHasCandidateNeutrino;
  int _fHasCandidateMuon;
  int _fNChargedPiCandidates;
  int _fNProtonCandidates;
  int _fNLeadCandidates;
  int _fNSubleadCandidates;
  int _fNPi0Candidates;
  int _fNPairCandidates;
  int _fNOtherFancyPairs;
  
  //DETECTOR SERVICES
  detinfo::DetectorProperties const * theDetector ;// = lar::providerFrom<detinfo::DetectorPropertiesService>();
  detinfo::DetectorClocks    const *  detClocks   ;//= lar::providerFrom<detinfo::DetectorClocksService>();
  spacecharge::SpaceCharge const * SCE;
  geo::GeometryCore const * geom;
  
  //CONSTANTS
  int m_Cryostat;
  int m_TPC;
  double m_wire_spacing;
  double m_width_dqdx_box;
  double m_length_dqdx_box;
  double _time2cm;
  int m_planes;

  //GAMMA ID's
  int Gamma1_E1_id;
  int Gamma1_E2_id;
  int Gamma2_E1_id;
  int Gamma2_E2_id;

  //OTHER CONSTANTS
  float yplanebias;
  float trunklength;
  float trunklength2;
  float trunkwidth;  
  float overlay_gain[3]; //for overlay
  float data_gain[3]; //for data

};


//////////////////// FHICL PARAMETER TAGS //////////////////////////////
CCpi0Tree::CCpi0Tree(fhicl::ParameterSet const & p) : EDAnalyzer(p){
  fEventWeightTag = p.get<std::string>("EventWeightProducer");
  fMCTruthTag = p.get<std::string>("MCTruthProducer");
  fGTruthTag = p.get<std::string>("GTruthProducer");
  fMCParticleTag = p.get<std::string>("MCParticleProducer");
  fPFParticleTag = p.get<std::string>("PFParticleProducer");
  fPFParticleMetadataTag = p.get<std::string>("PFParticleMetadataProducer");
  fShowerTag = p.get<std::string>("ShowerProducer");
  fMCShowerTag = p.get<std::string>("MCShowerProducer");
  fClusterTag = p.get<std::string>("ClusterProducer");
  fTrackTag = p.get<std::string>("TrackProducer");
  fTrackFitterTag = p.get<std::string>("TrackFitterProducer");
  fCaloTag = p.get<std::string>("CaloProducer");
  fHitTag = p.get<std::string>("HitProducer");
  fOpFlashTag = p.get<std::string>("OpFlashProducer");
  fHitPartAssnTag = p.get<std::string>("HitPartAssnProducer");
  fMCSFitResultTag = p.get<std::string>("MCSFitResultProducer");
  fIsMC = p.get<bool>("IsMC",true);
  fIsDirt = p.get<bool>("IsDirt",true);
  theDetector = lar::providerFrom<detinfo::DetectorPropertiesService>();
  detClocks   = lar::providerFrom<detinfo::DetectorClocksService>();
  SCE = lar::providerFrom<spacecharge::SpaceChargeService>();
  geom = lar::providerFrom<geo::Geometry>();
  // _min_track_len = p.get<double>("MinTrackLength", 0.1);
}//Fhicl parameter tags


void CCpi0Tree::beginJob()  {
  art::ServiceHandle<art::TFileService> tfs;

  trunklength = 3.;
  trunklength2 = 2.;
  trunkwidth = 1.;

  m_wire_spacing = 0.3;
  m_width_dqdx_box = 1.0;
  m_length_dqdx_box = 4.0;
  m_planes = 3;

  overlay_gain[0] = 245; //235.5; //245;
  overlay_gain[1] = 252; //249.7; //252;
  overlay_gain[2] = 237.6; //248.2;

  data_gain[0] = 232; //230.3; //232;
  data_gain[1] = 249; //237.6; //249;
  data_gain[2] = 243.7; //238.4;  

  yplanebias = 0.806; 
  
  Gamma1_E1_id = -999;
  Gamma1_E2_id = -999;
  Gamma2_E1_id = -999;
  Gamma2_E2_id = -999;

  _tree = 0;
  if(!_tree){
    _tree = tfs->make<TTree>("tree","tree");
    _tree->Branch("run",&_run,"run/I");
    _tree->Branch("subRun",&_subRun,"subRun/I");
    _tree->Branch("event",&_event,"event/I");
    _tree->Branch("pot",&_pot,"pot/D");
  }
  _run = 0;
  _subRun = 0;
  _pot = 0;

  _eventtree = 0;
  if(!_eventtree){
    _eventtree = tfs->make<TTree>("eventtree","eventtree");

    _eventtree->Branch("_f_All_Genie_Weights", "std::vector<float>", &_f_All_Genie_Weights);
    _eventtree->Branch("_f_RPA_CCQE_Genie_Weights", "std::vector<float>", &_f_RPA_CCQE_Genie_Weights);
    _eventtree->Branch("_f_XSecShape_CCMEC_Genie_Weights", "std::vector<float>", &_f_XSecShape_CCMEC_Genie_Weights);
    _eventtree->Branch("_f_AxFFCCQEshape_Genie_Weights", "std::vector<float>", &_f_AxFFCCQEshape_Genie_Weights);
    _eventtree->Branch("_f_VecFFCCQEshape_Genie_Weights", "std::vector<float>", &_f_VecFFCCQEshape_Genie_Weights);
    _eventtree->Branch("_f_DecayAngMEC_Genie_Weights", "std::vector<float>", &_f_DecayAngMEC_Genie_Weights);
    _eventtree->Branch("_f_Theta_Delta2Npi_Genie_Weights", "std::vector<float>", &_f_Theta_Delta2Npi_Genie_Weights);
    _eventtree->Branch("_f_expskin_FluxUnisim_Weights", "std::vector<float>", &_f_expskin_FluxUnisim_Weights);
    _eventtree->Branch("_f_horncurrent_FluxUnisim_Weights", "std::vector<float>", &_f_horncurrent_FluxUnisim_Weights);
    _eventtree->Branch("_f_kminus_PrimaryHadronNormalization_Weights", "std::vector<float>", &_f_kminus_PrimaryHadronNormalization_Weights);
    _eventtree->Branch("_f_kplus_PrimaryHadronFeynmanScaling_Weights", "std::vector<float>", &_f_kplus_PrimaryHadronFeynmanScaling_Weights);
    _eventtree->Branch("_f_kzero_PrimaryHadronSanfordWang_Weights", "std::vector<float>", &_f_kzero_PrimaryHadronSanfordWang_Weights);
    _eventtree->Branch("_f_nucleoninexsec_FluxUnisim_Weights", "std::vector<float>", &_f_nucleoninexsec_FluxUnisim_Weights);
    _eventtree->Branch("_f_nucleonqexsec_FluxUnisim_Weights", "std::vector<float>", &_f_nucleonqexsec_FluxUnisim_Weights);
    _eventtree->Branch("_f_nucleontotxsec_FluxUnisim_Weights", "std::vector<float>", &_f_nucleontotxsec_FluxUnisim_Weights);
    _eventtree->Branch("_f_piminus_PrimaryHadronSWCentralSplineVariation_Weights", "std::vector<float>", &_f_piminus_PrimaryHadronSWCentralSplineVariation_Weights);
    _eventtree->Branch("_f_pioninexsec_FluxUnisim_Weights", "std::vector<float>", &_f_pioninexsec_FluxUnisim_Weights);
    _eventtree->Branch("_f_pionqexsec_FluxUnisim_Weights", "std::vector<float>", &_f_pionqexsec_FluxUnisim_Weights);
    _eventtree->Branch("_f_piontotxsec_FluxUnisim_Weights", "std::vector<float>", &_f_piontotxsec_FluxUnisim_Weights);
    _eventtree->Branch("_f_piplus_PrimaryHadronSWCentralSplineVariation_Weights", "std::vector<float>", &_f_piplus_PrimaryHadronSWCentralSplineVariation_Weights);

    _eventtree->Branch("_fRun",&_fRun,"_fRun/I");
    _eventtree->Branch("_fSubRun",&_fSubRun,"_fSubRun/I");
    _eventtree->Branch("_fEvent",&_fEvent,"_fEvent/I");
    
    _eventtree->Branch("_fCVWeight",&_fCVWeight,"_fCVWeight/F");
    _eventtree->Branch("_fNuCCNC",&_fNuCCNC,"_fNuCCNC/I");
    _eventtree->Branch("_fNuMode",&_fNuMode,"_fNuMode/I");
    _eventtree->Branch("_fNuEnergy",&_fNuEnergy,"_fNuEnergy/F");
    _eventtree->Branch("_fNuVtxX",&_fNuVtxX,"_fNuVtxX/F");
    _eventtree->Branch("_fNuVtxY",&_fNuVtxY,"_fNuVtxY/F");
    _eventtree->Branch("_fNuVtxZ",&_fNuVtxZ,"_fNuVtxZ/F");
    _eventtree->Branch("_fNuPDG",&_fNuPDG,"_fNuPDG/I");
    _eventtree->Branch("_fNuInFV",&_fNuInFV,"_fNuInFV/I");
    _eventtree->Branch("_fResNum",&_fResNum,"_fResNum/I");

    _eventtree->Branch("_fLepPdg",&_fLepPdg,"_fLepPdg/I");
    _eventtree->Branch("_fLepP",&_fLepP,"_fLepP/F");
    _eventtree->Branch("_fLepPx",&_fLepPx,"_fLepPx/F");
    _eventtree->Branch("_fLepPy",&_fLepPy,"_fLepPy/F");
    _eventtree->Branch("_fLepPz",&_fLepPz,"_fLepPz/F");
    _eventtree->Branch("_fLepCosTheta",&_fLepCosTheta,"_fLepCosTheta/F");
    _eventtree->Branch("_fLepPhi",&_fLepPhi,"_fLepPhi/F");

    _eventtree->Branch("_fPi0E",&_fPi0E,"_fPi0E/F");
    _eventtree->Branch("_fPi0P",&_fPi0P,"_fPi0P/F");
    _eventtree->Branch("_fPi0M",&_fPi0M,"_fPi0M/F");
    _eventtree->Branch("_fPi0Px",&_fPi0Px,"_fPi0Px/F");
    _eventtree->Branch("_fPi0Py",&_fPi0Py,"_fPi0Py/F");
    _eventtree->Branch("_fPi0Pz",&_fPi0Pz,"_fPi0Pz/F");
    _eventtree->Branch("_fPi0CosTheta",&_fPi0CosTheta,"_fPi0CosTheta/F");
    _eventtree->Branch("_fPi0Phi",&_fPi0Phi,"_fPi0Phi/F");

    _eventtree->Branch("_fNpi0",&_fNpi0,"_fNpi0/I");
    _eventtree->Branch("_fNmuon",&_fNmuon,"_fNmuon/I");
    _eventtree->Branch("_fNproton",&_fNproton,"_fNproton/I");
    _eventtree->Branch("_fNpiplus",&_fNpiplus,"_fNpiplus/I");
    _eventtree->Branch("_fNneutron",&_fNneutron,"_fNneutron/I");

    _eventtree->Branch("_fGamma1_id",&_fGamma1_id,"_fGamma1_id/I");
    _eventtree->Branch("_fGamma2_id",&_fGamma2_id,"_fGamma2_id/I");
    _eventtree->Branch("_fGamma1_E",&_fGamma1_E,"_fGamma1_E/F");
    _eventtree->Branch("_fGamma2_E",&_fGamma2_E,"_fGamma2_E/F");
    _eventtree->Branch("_fGamma12_CosTheta",&_fGamma12_CosTheta,"_fGamma12_CosTheta/F");
    _eventtree->Branch("_fGamma12_Angle",&_fGamma12_Angle,"_fGamma12_Angle/F");
    _eventtree->Branch("_fGamma1_DirX",&_fGamma1_DirX,"_fGamma1_DirX/F");
    _eventtree->Branch("_fGamma1_DirY",&_fGamma1_DirY,"_fGamma1_DirY/F");
    _eventtree->Branch("_fGamma1_DirZ",&_fGamma1_DirZ,"_fGamma1_DirZ/F");
    _eventtree->Branch("_fGamma2_DirX",&_fGamma2_DirX,"_fGamma2_DirX/F");
    _eventtree->Branch("_fGamma2_DirY",&_fGamma2_DirY,"_fGamma2_DirY/F");
    _eventtree->Branch("_fGamma2_DirZ",&_fGamma2_DirZ,"_fGamma2_DirZ/F");
    _eventtree->Branch("_fGamma1E1_id",&_fGamma1E1_id,"_fGamma1E1_id/I");
    _eventtree->Branch("_fGamma1E2_id",&_fGamma1E2_id,"_fGamma1E2_id/I");
    _eventtree->Branch("_fGamma2E1_id",&_fGamma2E1_id,"_fGamma2E1_id/I");
    _eventtree->Branch("_fGamma2E2_id",&_fGamma2E2_id,"_fGamma2E2_id/I");

    _eventtree->Branch("_fSignalDefPi0Momentum", "std::vector<float>", &_fSignalDefPi0Momentum);
    _eventtree->Branch("_fSignalDefPiPlusMomentum", "std::vector<float>", &_fSignalDefPiPlusMomentum);
    _eventtree->Branch("_fSignalDefMuMomentum", "std::vector<float>", &_fSignalDefMuMomentum);

    _eventtree->Branch("_fCandidateMuonComposition",&_fCandidateMuonComposition,"_fCandidateMuonComposition/I");
    _eventtree->Branch("_fCandidateMuonMCSMomentumBias",&_fCandidateMuonMCSMomentumBias,"_fCandidateMuonMCSMomentumBias/F");
    _eventtree->Branch("_fCandidateMuonRangeMomentumBias",&_fCandidateMuonRangeMomentumBias,"_fCandidateMuonRangeMomentumBias/F");
    _eventtree->Branch("_fCandidateMuonMomentumBias",&_fCandidateMuonMomentumBias,"_fCandidateMuonMomentumBias/F");
    _eventtree->Branch("_fCandidateMuonAngleBiasCosine",&_fCandidateMuonAngleBiasCosine,"_fCandidateMuonAngleBiasCosine/F");
    _eventtree->Branch("_fCandidateMuonAngleBiasDegrees",&_fCandidateMuonAngleBiasDegrees,"_fCandidateMuonAngleBiasDegrees/F");

    _eventtree->Branch("_fCandidatePi0MomentumBias",&_fCandidatePi0MomentumBias,"_fCandidatePi0MomentumBias/F");
    _eventtree->Branch("_fCandidatePi0AngleBiasCosine",&_fCandidatePi0AngleBiasCosine,"_fCandidatePi0AngleBiasCosine/F");
    _eventtree->Branch("_fCandidatePi0AngleBiasDegrees",&_fCandidatePi0AngleBiasDegrees,"_fCandidatePi0AngleBiasDegrees/F");

    _eventtree->Branch("_fCandidateLeadComposition",&_fCandidateLeadComposition,"_fCandidateLeadComposition/I");
    _eventtree->Branch("_fCandidateLeadPurity",&_fCandidateLeadPurity,"_fCandidateLeadPurity/F");
    _eventtree->Branch("_fCandidateLeadCompleteness",&_fCandidateLeadCompleteness,"_fCandidateLeadCompleteness/F");
    _eventtree->Branch("_fCandidateLeadEnergyBias",&_fCandidateLeadEnergyBias,"_fCandidateLeadEnergyBias/F");
    _eventtree->Branch("_fCandidateLeadAngleBiasCosine",&_fCandidateLeadAngleBiasCosine,"_fCandidateLeadAngleBiasCosine/F");
    _eventtree->Branch("_fCandidateLeadAngleBiasDegrees",&_fCandidateLeadAngleBiasDegrees,"_fCandidateLeadAngleBiasDegrees/F");
    
    _eventtree->Branch("_fCandidateSubleadComposition",&_fCandidateSubleadComposition,"_fCandidateSubleadComposition/I");
    _eventtree->Branch("_fCandidateSubleadPurity",&_fCandidateSubleadPurity,"_fCandidateSubleadPurity/F");
    _eventtree->Branch("_fCandidateSubleadCompleteness",&_fCandidateSubleadCompleteness,"_fCandidateSubleadCompleteness/F");
    _eventtree->Branch("_fCandidateSubleadEnergyBias",&_fCandidateSubleadEnergyBias,"_fCandidateSubleadEnergyBias/F");
    _eventtree->Branch("_fCandidateSubleadAngleBiasCosine",&_fCandidateSubleadAngleBiasCosine,"_fCandidateSubleadAngleBiasCosine/F");
    _eventtree->Branch("_fCandidateSubleadAngleBiasDegrees",&_fCandidateSubleadAngleBiasDegrees,"_fCandidateSubleadAngleBiasDegrees/F");
    
    _eventtree->Branch("_fTrackComposition", "std::vector<int>", &_fTrackComposition);
    _eventtree->Branch("_fShowerComposition", "std::vector<int>", &_fShowerComposition);
    _eventtree->Branch("_fShowerPurity0", "std::vector<float>", &_fShowerPurity0);
    _eventtree->Branch("_fShowerPurity1", "std::vector<float>", &_fShowerPurity1);
    _eventtree->Branch("_fShowerPurity2", "std::vector<float>", &_fShowerPurity2);
    _eventtree->Branch("_fShowerPurity3", "std::vector<float>", &_fShowerPurity3);
    _eventtree->Branch("_fShowerCompleteness0", "std::vector<float>", &_fShowerCompleteness0);
    _eventtree->Branch("_fShowerCompleteness1", "std::vector<float>", &_fShowerCompleteness1);
    _eventtree->Branch("_fShowerCompleteness2", "std::vector<float>", &_fShowerCompleteness2);
    _eventtree->Branch("_fShowerCompleteness3", "std::vector<float>", &_fShowerCompleteness3);
    _eventtree->Branch("_fShowerEnergyBias0", "std::vector<float>", &_fShowerEnergyBias0);
    _eventtree->Branch("_fShowerEnergyBias1", "std::vector<float>", &_fShowerEnergyBias1);
    _eventtree->Branch("_fShowerEnergyBias2", "std::vector<float>", &_fShowerEnergyBias2);
    _eventtree->Branch("_fShowerEnergyBias3", "std::vector<float>", &_fShowerEnergyBias3);

    _eventtree->Branch("_fNTracks",&_fNTracks,"_fNTracks/I");
    _eventtree->Branch("_fNShowers",&_fNShowers,"_fNShowers/I");
    _eventtree->Branch("_fNHitsU",&_fNHitsU,"_fNHitsU/I");
    _eventtree->Branch("_fNHitsV",&_fNHitsV,"_fNHitsV/I");
    _eventtree->Branch("_fNHitsY",&_fNHitsY,"_fNHitsY/I");

    _eventtree->Branch("_fFlashChi2",&_fFlashChi2,"_fFlashChi2/F");
    _eventtree->Branch("_fFlashChi2Weight",&_fFlashChi2Weight,"_fFlashChi2Weight/F");
    _eventtree->Branch("_fFlashNewChi2Weight",&_fFlashNewChi2Weight,"_fFlashNewChi2Weight/F");
    _eventtree->Branch("_fFlashTime",&_fFlashTime,"_fFlashTime/D");
    _eventtree->Branch("_fFlashTimeWidth",&_fFlashTimeWidth,"_fFlashTimeWidth/D");
    _eventtree->Branch("_fFlashAbsTime",&_fFlashAbsTime,"_fFlashAbsTime/D");
    _eventtree->Branch("_fFlashTotalPE",&_fFlashTotalPE,"_fFlashTotalPE/D");
    _eventtree->Branch("_fFlashYCenter",&_fFlashYCenter,"_fFlashYCenter/D");
    _eventtree->Branch("_fFlashYWidth",&_fFlashYWidth,"_fFlashYWidth/D");
    _eventtree->Branch("_fFlashZCenter",&_fFlashZCenter,"_fFlashZCenter/D");
    _eventtree->Branch("_fFlashZWidth",&_fFlashZWidth,"_fFlashZWidth/D");

    _eventtree->Branch("_fCandidateVertexX",&_fCandidateVertexX,"_fCandidateVertexX/F");
    _eventtree->Branch("_fCandidateVertexY",&_fCandidateVertexY,"_fCandidateVertexY/F");
    _eventtree->Branch("_fCandidateVertexZ",&_fCandidateVertexZ,"_fCandidateVertexZ/F");

    _eventtree->Branch("_fCandidateMuonBestPlane",&_fCandidateMuonBestPlane,"_fCandidateMuonBestPlane/I");
    _eventtree->Branch("_fCandidateMuonIsContained",&_fCandidateMuonIsContained,"_fCandidateMuonIsContained/I");
    _eventtree->Branch("_fCandidateMuonDist3d",&_fCandidateMuonDist3d,"_fCandidateMuonDist3d/F");
    _eventtree->Branch("_fCandidateMuonAng3d",&_fCandidateMuonAng3d,"_fCandidateMuonAng3d/F");
    _eventtree->Branch("_fCandidateMuonPID",&_fCandidateMuonPID,"_fCandidateMuonPID/F");
    _eventtree->Branch("_fCandidateMuonStartX",&_fCandidateMuonStartX,"_fCandidateMuonStartX/F");
    _eventtree->Branch("_fCandidateMuonStartY",&_fCandidateMuonStartY,"_fCandidateMuonStartY/F");
    _eventtree->Branch("_fCandidateMuonStartZ",&_fCandidateMuonStartZ,"_fCandidateMuonStartZ/F");
    _eventtree->Branch("_fCandidateMuonEndX",&_fCandidateMuonEndX,"_fCandidateMuonEndX/F");
    _eventtree->Branch("_fCandidateMuonEndY",&_fCandidateMuonEndY,"_fCandidateMuonEndY/F");
    _eventtree->Branch("_fCandidateMuonEndZ",&_fCandidateMuonEndZ,"_fCandidateMuonEndZ/F");
    _eventtree->Branch("_fCandidateMuonMomentum",&_fCandidateMuonMomentum,"_fCandidateMuonMomentum/F");
    _eventtree->Branch("_fCandidateMuonMCSMomentum",&_fCandidateMuonMCSMomentum,"_fCandidateMuonMCSMomentum/F");
    _eventtree->Branch("_fCandidateMuonRangeMomentum",&_fCandidateMuonRangeMomentum,"_fCandidateMuonRangeMomentum/F");
    _eventtree->Branch("_fCandidateMuonLength",&_fCandidateMuonLength,"_fCandidateMuonLength/F");
    _eventtree->Branch("_fCandidateMuonCostheta",&_fCandidateMuonCostheta,"_fCandidateMuonCostheta/F");
    _eventtree->Branch("_fCandidateMuonPhi",&_fCandidateMuonPhi,"_fCandidateMuonPhi/F");
  
    _eventtree->Branch("_fCandidatePi0Momentum",&_fCandidatePi0Momentum,"_fCandidatePi0Momentum/F");
    _eventtree->Branch("_fCandidatePi0Costheta",&_fCandidatePi0Costheta,"_fCandidatePi0Costheta/F");
    _eventtree->Branch("_fCandidatePi0Phi",&_fCandidatePi0Phi,"_fCandidatePi0Phi/F");
    _eventtree->Branch("_fCandidatePi0Mass","std::vector<float>",&_fCandidatePi0Mass);
    _eventtree->Branch("_fCandidatePi0Energy",&_fCandidatePi0Energy,"_fCandidatePi0Energy/F");
    _eventtree->Branch("_fCandidatePi0Angle12",&_fCandidatePi0Angle12,"_fCandidatePi0Angle12/F");
  
    _eventtree->Branch("_fCandidateLeadBestPlane",&_fCandidateLeadBestPlane,"_fCandidateLeadBestPlane/I");
    _eventtree->Branch("_fCandidateLeadScore",&_fCandidateLeadScore,"_fCandidateLeadScore/F");
    _eventtree->Branch("_fCandidateLeadLength",&_fCandidateLeadLength,"_fCandidateLeadLength/F");
    _eventtree->Branch("_fCandidateLeadOpenAngle",&_fCandidateLeadOpenAngle,"_fCandidateLeadOpenAngle/F");
    _eventtree->Branch("_fCandidateLeadDirX",&_fCandidateLeadDirX,"_fCandidateLeadDirX/F");
    _eventtree->Branch("_fCandidateLeadDirY",&_fCandidateLeadDirY,"_fCandidateLeadDirY/F");
    _eventtree->Branch("_fCandidateLeadDirZ",&_fCandidateLeadDirZ,"_fCandidateLeadDirZ/F");
    _eventtree->Branch("_fCandidateLeadCostheta",&_fCandidateLeadCostheta,"_fCandidateLeadCostheta/F");
    _eventtree->Branch("_fCandidateLeadPhi",&_fCandidateLeadPhi,"_fCandidateLeadPhi/F");
    _eventtree->Branch("_fCandidateLeadThetaXZ",&_fCandidateLeadThetaXZ,"_fCandidateLeadThetaXZ/F");
    _eventtree->Branch("_fCandidateLeadThetaYZ",&_fCandidateLeadThetaYZ,"_fCandidateLeadThetaYZ/F");
    _eventtree->Branch("_fCandidateLeadDist3d",&_fCandidateLeadDist3d,"_fCandidateLeadDist3d/F");
    _eventtree->Branch("_fCandidateLeadAng3d",&_fCandidateLeadAng3d,"_fCandidateLeadAng3d/F");
    _eventtree->Branch("_fCandidateLeadStartX",&_fCandidateLeadStartX,"_fCandidateLeadStartX/F");
    _eventtree->Branch("_fCandidateLeadStartY",&_fCandidateLeadStartY,"_fCandidateLeadStartY/F");
    _eventtree->Branch("_fCandidateLeadStartZ",&_fCandidateLeadStartZ,"_fCandidateLeadStartZ/F");
    _eventtree->Branch("_fCandidateLeadEnergy",&_fCandidateLeadEnergy,"_fCandidateLeadEnergy/F");
    _eventtree->Branch("_fCandidateLeaddEdx0",&_fCandidateLeaddEdx0,"_fCandidateLeaddEdx0/F");
    _eventtree->Branch("_fCandidateLeaddEdx1",&_fCandidateLeaddEdx1,"_fCandidateLeaddEdx1/F");
    _eventtree->Branch("_fCandidateLeaddEdx2",&_fCandidateLeaddEdx2,"_fCandidateLeaddEdx2/F");
    _eventtree->Branch("_fCandidateLeaddEdx3",&_fCandidateLeaddEdx3,"_fCandidateLeaddEdx3/F");
    
    _eventtree->Branch("_fCandidateSubleadBestPlane",&_fCandidateSubleadBestPlane,"_fCandidateSubleadBestPlane/I");
    _eventtree->Branch("_fCandidateSubleadScore",&_fCandidateSubleadScore,"_fCandidateSubleadScore/F");
    _eventtree->Branch("_fCandidateSubleadLength",&_fCandidateSubleadLength,"_fCandidateSubleadLength/F");
    _eventtree->Branch("_fCandidateSubleadOpenAngle",&_fCandidateSubleadOpenAngle,"_fCandidateSubleadOpenAngle/F");
    _eventtree->Branch("_fCandidateSubleadDirX",&_fCandidateSubleadDirX,"_fCandidateSubleadDirX/F");
    _eventtree->Branch("_fCandidateSubleadDirY",&_fCandidateSubleadDirY,"_fCandidateSubleadDirY/F");
    _eventtree->Branch("_fCandidateSubleadDirZ",&_fCandidateSubleadDirZ,"_fCandidateSubleadDirZ/F");
    _eventtree->Branch("_fCandidateSubleadCostheta",&_fCandidateSubleadCostheta,"_fCandidateSubleadCostheta/F");
    _eventtree->Branch("_fCandidateSubleadPhi",&_fCandidateSubleadPhi,"_fCandidateSubleadPhi/F");
    _eventtree->Branch("_fCandidateSubleadThetaXZ",&_fCandidateSubleadThetaXZ,"_fCandidateSubleadThetaXZ/F");
    _eventtree->Branch("_fCandidateSubleadThetaYZ",&_fCandidateSubleadThetaYZ,"_fCandidateSubleadThetaYZ/F");
    _eventtree->Branch("_fCandidateSubleadDist3d",&_fCandidateSubleadDist3d,"_fCandidateSubleadDist3d/F");
    _eventtree->Branch("_fCandidateSubleadAng3d",&_fCandidateSubleadAng3d,"_fCandidateSubleadAng3d/F");
    _eventtree->Branch("_fCandidateSubleadStartX",&_fCandidateSubleadStartX,"_fCandidateSubleadStartX/F");
    _eventtree->Branch("_fCandidateSubleadStartY",&_fCandidateSubleadStartY,"_fCandidateSubleadStartY/F");
    _eventtree->Branch("_fCandidateSubleadStartZ",&_fCandidateSubleadStartZ,"_fCandidateSubleadStartZ/F");
    _eventtree->Branch("_fCandidateSubleadEnergy",&_fCandidateSubleadEnergy,"_fCandidateSubleadEnergy/F");
    _eventtree->Branch("_fCandidateSubleaddEdx0",&_fCandidateSubleaddEdx0,"_fCandidateSubleaddEdx0/F");
    _eventtree->Branch("_fCandidateSubleaddEdx1",&_fCandidateSubleaddEdx1,"_fCandidateSubleaddEdx1/F");
    _eventtree->Branch("_fCandidateSubleaddEdx2",&_fCandidateSubleaddEdx2,"_fCandidateSubleaddEdx2/F");
    _eventtree->Branch("_fCandidateSubleaddEdx3",&_fCandidateSubleaddEdx3,"_fCandidateSubleaddEdx3/F");

    _eventtree->Branch("_fTrackBestPlane", "std::vector<int>", &_fTrackBestPlane);
    _eventtree->Branch("_fTrackIsContained", "std::vector<int>", &_fTrackIsContained);
    _eventtree->Branch("_fTrackDist3d", "std::vector<float>", &_fTrackDist3d);
    _eventtree->Branch("_fTrackAng3d", "std::vector<float>", &_fTrackAng3d);
    _eventtree->Branch("_fTrackPID", "std::vector<float>", &_fTrackPID);
    _eventtree->Branch("_fTrackStartX", "std::vector<float>", &_fTrackStartX);
    _eventtree->Branch("_fTrackStartY", "std::vector<float>", &_fTrackStartY);
    _eventtree->Branch("_fTrackStartZ", "std::vector<float>", &_fTrackStartZ);
    _eventtree->Branch("_fTrackEndX", "std::vector<float>", &_fTrackEndX);
    _eventtree->Branch("_fTrackEndY", "std::vector<float>", &_fTrackEndY);
    _eventtree->Branch("_fTrackEndZ", "std::vector<float>", &_fTrackEndZ);
    _eventtree->Branch("_fTrackMomentum", "std::vector<float>", &_fTrackMomentum);
    _eventtree->Branch("_fTrackLength", "std::vector<float>", &_fTrackLength);
    _eventtree->Branch("_fTrackCostheta", "std::vector<float>", &_fTrackCostheta);
    _eventtree->Branch("_fTrackPhi", "std::vector<float>", &_fTrackPhi);
   
    _eventtree->Branch("_fShowerBestPlane", "std::vector<int>", &_fShowerBestPlane);
    _eventtree->Branch("_fTrackShowerScore", "std::vector<float>", &_fTrackShowerScore);
    _eventtree->Branch("_fShowerLength", "std::vector<float>", &_fShowerLength);
    _eventtree->Branch("_fShowerOpenAngle", "std::vector<float>", &_fShowerOpenAngle);
    _eventtree->Branch("_fShowerDirX", "std::vector<float>", &_fShowerDirX);
    _eventtree->Branch("_fShowerDirY", "std::vector<float>", &_fShowerDirY);
    _eventtree->Branch("_fShowerDirZ", "std::vector<float>", &_fShowerDirZ);
    _eventtree->Branch("_fShowerCostheta", "std::vector<float>", &_fShowerCostheta);
    _eventtree->Branch("_fShowerPhi", "std::vector<float>", &_fShowerPhi);
    _eventtree->Branch("_fShowerThetaXZ", "std::vector<float>", &_fShowerThetaXZ);
    _eventtree->Branch("_fShowerThetaYZ", "std::vector<float>", &_fShowerThetaYZ);
    _eventtree->Branch("_fShowerDist3d", "std::vector<float>", &_fShowerDist3d);
    _eventtree->Branch("_fShowerAng3d", "std::vector<float>", &_fShowerAng3d);
    _eventtree->Branch("_fShowerStartX", "std::vector<float>", &_fShowerStartX);
    _eventtree->Branch("_fShowerStartY", "std::vector<float>", &_fShowerStartY);
    _eventtree->Branch("_fShowerStartZ", "std::vector<float>", &_fShowerStartZ);
    _eventtree->Branch("_fShowerEnergy0", "std::vector<float>", &_fShowerEnergy0);
    _eventtree->Branch("_fShowerEnergy1", "std::vector<float>", &_fShowerEnergy1);
    _eventtree->Branch("_fShowerEnergy2", "std::vector<float>", &_fShowerEnergy2);
    _eventtree->Branch("_fShowerEnergy3", "std::vector<float>", &_fShowerEnergy3);
    _eventtree->Branch("_fShowerdEdx0", "std::vector<float>", &_fShowerdEdx0);
    _eventtree->Branch("_fShowerdEdx1", "std::vector<float>", &_fShowerdEdx1);
    _eventtree->Branch("_fShowerdEdx2", "std::vector<float>", &_fShowerdEdx2);
    _eventtree->Branch("_fShowerdEdx3", "std::vector<float>", &_fShowerdEdx3);
  
    _eventtree->Branch("_fHasCandidateNeutrino",&_fHasCandidateNeutrino,"_fHasCandidateNeutrino/I");
    _eventtree->Branch("_fHasCandidateMuon",&_fHasCandidateMuon,"_fHasCandidateMuon/I");
    _eventtree->Branch("_fNChargedPiCandidates",&_fNChargedPiCandidates,"_fNChargedPiCandidates/I");
    _eventtree->Branch("_fNProtonCandidates",&_fNProtonCandidates,"_fNProtonCandidates/I");
    _eventtree->Branch("_fNLeadCandidates",&_fNLeadCandidates,"_fNLeadCandidates/I");
    _eventtree->Branch("_fNSubleadCandidates",&_fNSubleadCandidates,"_fNSubleadCandidates/I");
    _eventtree->Branch("_fNPi0Candidates",&_fNPi0Candidates,"_fNPi0Candidates/I");
    _eventtree->Branch("_fNPairCandidates",&_fNPairCandidates,"_fNPairCandidates/I");
    _eventtree->Branch("_fNOtherFancyPairs",&_fNOtherFancyPairs,"_fNOtherFancyPairs/I");
    
  }
  
}//Begin job

void CCpi0Tree::analyze(art::Event const & e){

  // Get the MC information    
  art::Handle<std::vector<simb::MCTruth>> MCTruthHandle;
  std::vector<art::Ptr<simb::MCTruth>> MCTruthVector;
  if (e.getByLabel(fMCTruthTag, MCTruthHandle)){art::fill_ptr_vector(MCTruthVector, MCTruthHandle);}
  
  art::Handle<std::vector<simb::GTruth>> GTruthHandle;
  std::vector<art::Ptr<simb::GTruth>> GTruthVector;
  if (e.getByLabel(fGTruthTag, GTruthHandle)){art::fill_ptr_vector(GTruthVector, GTruthHandle);}
  
  art::Handle<std::vector<simb::MCParticle>> MCParticleHandle;
  std::vector<art::Ptr<simb::MCParticle>> MCParticleVector;
  if (e.getByLabel(fMCParticleTag, MCParticleHandle)){art::fill_ptr_vector(MCParticleVector, MCParticleHandle);}
  
  //Get the other reco products
  art::Handle<std::vector<recob::PFParticle>> PFParticleHandle;
  std::vector<art::Ptr<recob::PFParticle>> PFParticleVector;
  if (e.getByLabel(fPFParticleTag, PFParticleHandle)){art::fill_ptr_vector(PFParticleVector, PFParticleHandle);}

  art::Handle<std::vector<sim::MCShower>> MCShowerHandle;
  std::vector<art::Ptr<sim::MCShower>> MCShowerVector;
  if (e.getByLabel(fMCShowerTag, MCShowerHandle)){art::fill_ptr_vector(MCShowerVector, MCShowerHandle);}
  
  art::Handle<std::vector<recob::Shower>> ShowerHandle;
  std::vector<art::Ptr<recob::Shower>> ShowerVector;
  if (e.getByLabel(fShowerTag, ShowerHandle)){art::fill_ptr_vector(ShowerVector, ShowerHandle);}
  
  art::Handle<std::vector<recob::Cluster>> ClusterHandle;
  std::vector<art::Ptr<recob::Cluster>> ClusterVector;
  if (e.getByLabel(fClusterTag, ClusterHandle)){art::fill_ptr_vector(ClusterVector, ClusterHandle);}
  
  art::Handle<std::vector<recob::Track>> TrackHandle;
  std::vector<art::Ptr<recob::Track>> TrackVector;
  if (e.getByLabel(fTrackTag, TrackHandle)){art::fill_ptr_vector(TrackVector, TrackHandle);}
  
  art::Handle<std::vector<recob::Track>> TrackFitterHandle;
  std::vector<art::Ptr<recob::Track>> TrackFitterVector;
  if (e.getByLabel(fTrackFitterTag, TrackFitterHandle)){art::fill_ptr_vector(TrackFitterVector, TrackFitterHandle);}
  
  art::Handle<std::vector<recob::Hit>> HitHandle;
  std::vector<art::Ptr<recob::Hit>> HitVector;
  if (e.getByLabel(fHitTag, HitHandle)){art::fill_ptr_vector(HitVector, HitHandle);}

  art::Handle<std::vector<recob::OpFlash>> OpFlashHandle;
  std::vector<art::Ptr<recob::OpFlash>> OpFlashVector;
  if (e.getByLabel(fOpFlashTag, OpFlashHandle)){art::fill_ptr_vector(OpFlashVector, OpFlashHandle);}
  
  art::Handle<std::vector<recob::MCSFitResult> > MCSFitResultHandle;
  std::vector<art::Ptr<recob::MCSFitResult>> MCSFitResultVector;
  if(e.getByLabel(fMCSFitResultTag, MCSFitResultHandle)){art::fill_ptr_vector(MCSFitResultVector, MCSFitResultHandle);}
  

  art::FindManyP<recob::Hit>  fmhs(ShowerHandle, e, fShowerTag);
  art::FindManyP<recob::Hit>  fmht(TrackHandle, e, fTrackTag);
  art::FindManyP<recob::Hit>  fmhc(ClusterHandle, e, fClusterTag);
  art::FindManyP<recob::Cluster>  fmcs(ShowerHandle, e, fShowerTag);
  art::FindManyP<recob::Shower> pfPartToShowerAssoc(PFParticleHandle, e, "pandora");
  art::FindManyP<recob::Cluster> pfPartToClusterAssoc(PFParticleHandle, e, "pandora");
  art::FindManyP<recob::Track> trackFitterAssoc(PFParticleHandle, e, "pandoraKalmanShower");
  std::vector<art::Ptr<recob::Track> > nuTracks;
  std::map< art::Ptr<recob::Shower> , float > nuShowers_ScoreMap; //map from shower to score
  std::map< art::Ptr<recob::Track> , float > nuTracks_ScoreMap; //map from track to score
  std::map< art::Ptr<recob::Shower> , int > nuShowerTrackMap;

  //CUT VARIABLES
  //cut 1: cc inclusive filter
  std::vector<art::Ptr<recob::Vertex> > nuVertex;
  std::vector<art::Ptr<recob::Track> > nuMuon;
  //cut 2: charged pi veto
  int nchargedpicand = 0;
  //cut 3: nshowers >= 2
  std::vector<art::Ptr<recob::Shower> > nuShowers;
  //cut 4: >= 1 lead
  std::vector<art::Ptr<recob::Shower>> TheLeadVector;
  std::vector<art::Ptr<recob::Shower>> LeadCandidates; //all showers that pass lead requirements
  std::vector<art::Ptr<recob::Shower>> LeadCandidatesCL;
  std::vector<art::Ptr<recob::Shower>> LeadCandidatesEN;
  std::vector<art::Ptr<recob::Shower>> LeadCandidatesRA;
  //cut 5: >= 1 sublead
  std::vector<art::Ptr<recob::Shower>> TheSubleadVector;
  std::vector<art::Ptr<recob::Shower>> SubleadCandidates; //all showers that pass sublead requirements
  std::vector<art::Ptr<recob::Shower>> SubleadCandidatesCL;
  std::vector<art::Ptr<recob::Shower>> SubleadCandidatesEN;
  //cut 6: exactly one pair passes mass cut
  int npairs = 0;
  int notherfancypairs = 0;

  //////
  int MuonComposition = -999;
  double MuonAngleBiasCosine = -999;
  double MuonAngleBiasDegrees = -999;
  double MuonMCSMomentumBias = -999;
  double MuonRangeMomentumBias = -999;
  double MuonMomentumBias = -999;
  int MuonBestPlane = -999;
  int MuonIsContained = -999;
  float MuonDist3d = -999;
  float MuonAng3d = -999;
  float VertexX = -999;
  float VertexY = -999;
  float VertexZ = -999;
  float MuonStartX = -999;
  float MuonStartY = -999;
  float MuonStartZ = -999;
  float MuonEndX = -999;
  float MuonEndY = -999;
  float MuonEndZ = -999;
  float MuonMomentum = -999;
  float MuonMCSMomentum = -999;
  float MuonRangeMomentum = -999;
  float MuonLength = -999;
  float MuonCostheta = -999;
  float MuonPhi = -999;
  int MuonID = -999;
  float MuonPID = -999999;

  std::cout<<MuonAng3d<<std::endl;
  
  //
  double flashchi2 = -999999.;
  double flashchi2weight = -9999999.;
  double flashnewchi2weight = -9999999.;
  
  ///////////////////////////////////////// ALL TREE VARIABLES //////////////////////////
  _fRun = -999;
  _fSubRun = -999;
  _fEvent = -999;
  _fCVWeight = -999;
  _fNuCCNC = -999;
  _fNuMode = -999;
  _fNuEnergy = -999;
  _fNuVtxX = -999;
  _fNuVtxY = -999;
  _fNuVtxZ = -999;
  _fNuPDG = -999;
  _fNuInFV = -999;
  _fResNum = -999;

  _fLepPdg = -999;
  _fLepP = -999;
  _fLepPx = -999;
  _fLepPy = -999;
  _fLepPz = -999;
  _fLepCosTheta = -999;
  _fLepPhi = -999; 

  _fPi0E = -999;
  _fPi0P = -999;
  _fPi0M = -999;
  _fPi0Px = -999;
  _fPi0Py = -999;
  _fPi0Pz = -999;
  _fPi0CosTheta = -999;
  _fPi0Phi = -999;

  _fNpi0 = -999;
  _fNmuon = -999;
  _fNpiplus = -999;
  _fNproton = -999;
  _fNneutron = -999;

  _fGamma1_id = -999;
  _fGamma2_id = -999;
  _fGamma1_E = -999;
  _fGamma2_E = -999;
  _fGamma12_CosTheta = -999;
  _fGamma12_Angle = -999;
  
  _fGamma1_DirX = -999;
  _fGamma1_DirY = -999;
  _fGamma1_DirZ = -999;
  
  _fGamma2_DirX = -999;
  _fGamma2_DirY = -999;
  _fGamma2_DirZ = -999;      
  
  _fGamma1E1_id = -999;
  _fGamma1E2_id = -999;
  _fGamma2E1_id = -999;
  _fGamma2E2_id = -999;

  _fCandidateMuonComposition = -999;
  _fCandidateMuonMCSMomentumBias = -999;
  _fCandidateMuonRangeMomentumBias = -999;
  _fCandidateMuonMomentumBias = -999;
  _fCandidateMuonAngleBiasCosine = -999;
  _fCandidateMuonAngleBiasDegrees = -999;
  _fCandidatePi0MomentumBias = -999;
  _fCandidatePi0AngleBiasCosine = -999;
  _fCandidatePi0AngleBiasDegrees = -999;
  _fCandidateLeadComposition = -999;
  _fCandidateLeadPurity = -999;
  _fCandidateLeadCompleteness = -999;
  _fCandidateLeadEnergyBias = -999;
  _fCandidateLeadAngleBiasCosine = -999;
  _fCandidateLeadAngleBiasDegrees = -999;
  _fCandidateSubleadComposition = -999;
  _fCandidateSubleadPurity = -999;
  _fCandidateSubleadCompleteness = -999;
  _fCandidateSubleadEnergyBias = -999;
  _fCandidateSubleadAngleBiasCosine = -999;
  _fCandidateSubleadAngleBiasDegrees = -999;

  _fNTracks = -999;
  _fNShowers = -999;
  _fNHitsU = -999;
  _fNHitsV = -999;
  _fNHitsY = -999;

  _fFlashChi2 = -999;
  _fFlashChi2Weight = -999;
  _fFlashNewChi2Weight = -999;
  _fFlashTime = -999;
  _fFlashTimeWidth = -999;
  _fFlashAbsTime = -999;
  _fFlashTotalPE = -999;
  _fFlashYCenter = -999;
  _fFlashYWidth = -999;
  _fFlashZCenter = -999;
  _fFlashZWidth = -999;
  
  _fCandidateVertexX = -999;
  _fCandidateVertexY = -999;
  _fCandidateVertexZ = -999;
  
  _fCandidateMuonBestPlane = -999;
  _fCandidateMuonIsContained = -999;
  _fCandidateMuonDist3d = -999;
  _fCandidateMuonAng3d = -999;
  _fCandidateMuonPID = -999;
  _fCandidateMuonStartX = -999;
  _fCandidateMuonStartY = -999;
  _fCandidateMuonStartZ = -999;
  _fCandidateMuonEndX = -999;
  _fCandidateMuonEndY = -999;
  _fCandidateMuonEndZ = -999;
  _fCandidateMuonMomentum = -999;
  _fCandidateMuonMCSMomentum = -999;
  _fCandidateMuonRangeMomentum = -999;
  _fCandidateMuonLength = -999;
  _fCandidateMuonCostheta = -999;
  _fCandidateMuonPhi = -999;
   
  _fCandidatePi0Momentum = -999;
  _fCandidatePi0Costheta = -999;
  _fCandidatePi0Phi = -999;
  _fCandidatePi0Energy = -999;
  _fCandidatePi0Angle12 = -999;
 
  _fCandidateLeadBestPlane = -999;
  _fCandidateLeadScore = -999;
  _fCandidateLeadLength = -999;
  _fCandidateLeadOpenAngle = -999;
  _fCandidateLeadDirX = -999;
  _fCandidateLeadDirY = -999;
  _fCandidateLeadDirZ = -999;
  _fCandidateLeadCostheta = -999;
  _fCandidateLeadPhi = -999;
  _fCandidateLeadThetaXZ = -999;
  _fCandidateLeadThetaYZ = -999;
  _fCandidateLeadDist3d = -999;
  _fCandidateLeadAng3d = -999;
  _fCandidateLeadStartX = -999;
  _fCandidateLeadStartY = -999;
  _fCandidateLeadStartZ = -999;
  _fCandidateLeadEnergy = -999;
  _fCandidateLeaddEdx0 = -999;
  _fCandidateLeaddEdx1 = -999;
  _fCandidateLeaddEdx2 = -999;
  _fCandidateLeaddEdx3 = -999;
  
  _fCandidateSubleadBestPlane = -999;
  _fCandidateSubleadScore = -999;
  _fCandidateSubleadLength = -999;
  _fCandidateSubleadOpenAngle = -999;
  _fCandidateSubleadDirX = -999;
  _fCandidateSubleadDirY = -999;
  _fCandidateSubleadDirZ = -999;
  _fCandidateSubleadCostheta = -999;
  _fCandidateSubleadPhi = -999;
  _fCandidateSubleadThetaXZ = -999;
  _fCandidateSubleadThetaYZ = -999;
  _fCandidateSubleadDist3d = -999;
  _fCandidateSubleadAng3d = -999;
  _fCandidateSubleadStartX = -999;
  _fCandidateSubleadStartY = -999;
  _fCandidateSubleadStartZ = -999;
  _fCandidateSubleadEnergy = -999;
  _fCandidateSubleaddEdx0 = -999;
  _fCandidateSubleaddEdx1 = -999;
  _fCandidateSubleaddEdx2 = -999;
  _fCandidateSubleaddEdx3 = -999;

  _fHasCandidateNeutrino = -999;
  _fHasCandidateMuon = -999;
  _fNChargedPiCandidates = -999;
  _fNProtonCandidates = -999;
  _fNLeadCandidates = -999;
  _fNSubleadCandidates = -999;
  _fNPi0Candidates = -999;
  _fNPairCandidates = -999;
  _fNOtherFancyPairs = -999;

  _f_All_Genie_Weights.clear();
  _f_RPA_CCQE_Genie_Weights.clear();
  _f_XSecShape_CCMEC_Genie_Weights.clear();
  _f_AxFFCCQEshape_Genie_Weights.clear();
  _f_VecFFCCQEshape_Genie_Weights.clear();
  _f_DecayAngMEC_Genie_Weights.clear();
  _f_Theta_Delta2Npi_Genie_Weights.clear();
  _f_expskin_FluxUnisim_Weights.clear();
  _f_horncurrent_FluxUnisim_Weights.clear();
  _f_kminus_PrimaryHadronNormalization_Weights.clear();
  _f_kplus_PrimaryHadronFeynmanScaling_Weights.clear();
  _f_kzero_PrimaryHadronSanfordWang_Weights.clear();
  _f_nucleoninexsec_FluxUnisim_Weights.clear();
  _f_nucleonqexsec_FluxUnisim_Weights.clear();
  _f_nucleontotxsec_FluxUnisim_Weights.clear();
  _f_piminus_PrimaryHadronSWCentralSplineVariation_Weights.clear();
  _f_pioninexsec_FluxUnisim_Weights.clear();
  _f_pionqexsec_FluxUnisim_Weights.clear();
  _f_piontotxsec_FluxUnisim_Weights.clear();
  _f_piplus_PrimaryHadronSWCentralSplineVariation_Weights.clear();
  _fSignalDefPi0Momentum.clear();
  _fSignalDefPiPlusMomentum.clear();
  _fSignalDefMuMomentum.clear();
  _fCandidatePi0Mass.clear();
  _fTrackTrueComposition0.clear();
  _fTrackTrueComposition1.clear();
  _fTrackTrueComposition2.clear();
  _fTrackTrueComposition.clear();
  _fTrackBestPlane.clear();
  _fTrackIsContained.clear();
  _fTrackDist3d.clear();
  _fTrackAng3d.clear();
  _fTrackPID.clear();
  _fTrackStartX.clear();
  _fTrackStartY.clear();
  _fTrackStartZ.clear();
  _fTrackEndX.clear();
  _fTrackEndY.clear();
  _fTrackEndZ.clear();
  _fTrackMomentum.clear();
  _fTrackLength.clear();
  _fTrackCostheta.clear();
  _fTrackPhi.clear();
  _fShowerBestPlane.clear();
  _fTrackShowerScore.clear();
  _fShowerLength.clear();
  _fShowerOpenAngle.clear();
  _fShowerDirX.clear();
  _fShowerDirY.clear();
  _fShowerDirZ.clear();
  _fShowerCostheta.clear();
  _fShowerPhi.clear();
  _fShowerThetaXZ.clear();
  _fShowerThetaYZ.clear();
  _fShowerDist3d.clear();
  _fShowerAng3d.clear();
  _fShowerStartX.clear();
  _fShowerStartY.clear();
  _fShowerStartZ.clear();
  _fShowerEnergy0.clear();
  _fShowerEnergy1.clear();
  _fShowerEnergy2.clear();
  _fShowerEnergy3.clear();
  _fShowerdEdx0.clear();
  _fShowerdEdx1.clear();
  _fShowerdEdx2.clear();
  _fShowerdEdx3.clear();
  _fTrackComposition.clear();
  _fShowerComposition.clear();
  _fShowerPurity0.clear();
  _fShowerPurity1.clear();
  _fShowerPurity2.clear();
  _fShowerPurity3.clear();
  _fShowerCompleteness0.clear();
  _fShowerCompleteness1.clear();
  _fShowerCompleteness2.clear();
  _fShowerCompleteness3.clear();
  _fShowerEnergyBias0.clear();
  _fShowerEnergyBias1.clear();
  _fShowerEnergyBias2.clear();
  _fShowerEnergyBias3.clear();

  //////////////////////////////////////////////////////////////////////////////
  ///////////////////////////// EVENT TRUTH INFO ///////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
 
  _fRun = e.run();
  _fSubRun = e.subRun();
  _fEvent = e.event();

  std::cout<<"RUN SUBRUN EVENT in EVENT LOOP "<<_fRun<<" "<<_fSubRun<<" "<<_fEvent<<std::endl;
  
  int Npi0 = 0;
  int Nmuon = 0;
  int Npiplus = 0;
  int Nproton = 0;
  int Nneutron = 0;
  
  std::vector<art::Ptr<simb::MCParticle>> NuPi0;
  std::vector<art::Ptr<simb::MCParticle>> TwoGammaV;
  std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents;
  std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents;
    
  if(fIsMC){
      
    if(MCTruthVector[0]->NeutrinoSet()){ //neutrino information
      _fNuPDG = MCTruthVector[0]->GetNeutrino().Nu().PdgCode();
      _fNuCCNC = MCTruthVector[0]->GetNeutrino().CCNC();
      _fNuVtxX = MCTruthVector[0]->GetNeutrino().Nu().Vx();
      _fNuVtxY = MCTruthVector[0]->GetNeutrino().Nu().Vy();
      _fNuVtxZ = MCTruthVector[0]->GetNeutrino().Nu().Vz();
      _fNuEnergy =  1000*(MCTruthVector[0]->GetNeutrino().Nu().E());
      _fNuMode = MCTruthVector[0]->GetNeutrino().Mode();
      if(inFV(_fNuVtxX,_fNuVtxY,_fNuVtxZ) == true){_fNuInFV = 1;}
      if(inFV(_fNuVtxX,_fNuVtxY,_fNuVtxZ) == false){_fNuInFV = 0;}
	
      _fLepPdg = MCTruthVector[0]->GetNeutrino().Lepton().PdgCode();
      if(_fLepPdg == 13 || _fLepPdg == -13){
	_fLepP = (MCTruthVector[0]->GetNeutrino().Lepton().P())*1000;
	_fLepPx = (MCTruthVector[0]->GetNeutrino().Lepton().Px())*1000;
	_fLepPy = (MCTruthVector[0]->GetNeutrino().Lepton().Py())*1000;
	_fLepPz = (MCTruthVector[0]->GetNeutrino().Lepton().Pz())*1000;
	_fLepCosTheta = _fLepPz/_fLepP;
	_fLepPhi = getPhi(_fLepPx, _fLepPy, _fLepPz);       
      }

      if(GTruthVector.size() == 1){
	_fResNum = GTruthVector[0]->fResNum;
      }
	
    }//neutrino set
      
    ////// HOW MANY TRUE PI0'S? //////
           
    for(auto const& mcpart : MCParticleVector){ //list of mc particles

      float momentum = mcpart->P()*1000;
      if(std::abs(mcpart->PdgCode()) == 111 && mcpart->Process() == "primary"){
	_fSignalDefPi0Momentum.push_back(momentum);
      }
      if(std::abs(mcpart->PdgCode()) == 211 && mcpart->Process() == "primary"){
	_fSignalDefPiPlusMomentum.push_back(momentum);
      }
      if(std::abs(mcpart->PdgCode()) == 13 && mcpart->Process() == "primary"){
	_fSignalDefMuMomentum.push_back(momentum);
      }
       
      if(std::abs(mcpart->PdgCode()) == 111 && mcpart->Process() == "primary" && mcpart->P()*1000 < 800.){ 
	Npi0++;
	NuPi0.push_back(mcpart);
      }
      if(std::abs(mcpart->PdgCode()) == 13 && mcpart->Process() == "primary" && mcpart->P()*1000 > 150.){ 
	Nmuon++;
      }
      if(std::abs(mcpart->PdgCode()) == 211 && mcpart->Process() == "primary" && mcpart->P()*1000 > 70.){ 
	Npiplus++;
      }
      if(std::abs(mcpart->PdgCode()) == 2212 && mcpart->Process() == "primary"){ 
	Nproton++;
      }
      if(std::abs(mcpart->PdgCode()) == 2112 && mcpart->Process() == "primary"){ 
	Nneutron++;
      }
    }//mcparticles

    ////// TRUE SIGNAL EVENTS //////
    if(_fNuInFV == 1 && std::abs(_fNuPDG) == 14 && _fNuCCNC == 0 && Npi0 == 1 && Nmuon == 1 && Npiplus == 0){
	 
      if(NuPi0.size() == 1){
	_fPi0P = NuPi0.at(0)->P()*1000;
	_fPi0E = NuPi0.at(0)->E()*1000;
	_fPi0Px = NuPi0.at(0)->Px();
	_fPi0Py = NuPi0.at(0)->Py();
	_fPi0Pz = NuPi0.at(0)->Pz();
	_fPi0CosTheta = (_fPi0Pz*1000)/_fPi0P;
	_fPi0Phi = getPhi(_fPi0Px, _fPi0Py, _fPi0Pz);
      }
	
      //get pi0 daughters (gammas)
      auto const nupi0 = NuPi0.at(0);
      for(int i = 0; i < nupi0->NumberDaughters(); i++){
	for(auto const& mcpart : MCParticleVector){
	  if(mcpart->TrackId() != nupi0->Daughter(i)) continue; 
	  TwoGammaV.push_back(mcpart);
	}
      }

      //get higher and lower energy gammas
      float Gamma1_tempe = -9999.;
      float Gamma2_tempe = -9999.;
	
      for(auto const& gamma : TwoGammaV){
	if(gamma->E() > Gamma1_tempe){
	  Gamma1_tempe = gamma->E();
	  _fGamma1_id = gamma->TrackId();
	}
      }
      for(auto const& gamma : TwoGammaV){
	if(gamma->TrackId() == _fGamma1_id) continue;
	_fGamma2_id = gamma->TrackId();
	Gamma2_tempe = gamma->E();
      }

      _fGamma1_E = Gamma1_tempe*1000;
      _fGamma2_E = Gamma2_tempe*1000;
	
      for(auto const& gamma : TwoGammaV){

	//Gamma1
	if(gamma->TrackId() == _fGamma1_id){
	  if(gamma->NumberDaughters() == 2){
	    _fGamma1E1_id = gamma->Daughter(0);
	    _fGamma1E2_id = gamma->Daughter(1);
	  }//2 daughters
	}//gamma1

	//Gamma2
	if(gamma->TrackId() == _fGamma2_id){
	  if(gamma->NumberDaughters() == 2){
	    _fGamma2E1_id = gamma->Daughter(0);
	    _fGamma2E2_id = gamma->Daughter(1);
	  }//2 daughters
	}//gamma1
	  
      }
      //////////////// ALL DESCENDENTS //////////////
	
      getKids(MCParticleVector,_fGamma1_id,Gamma1_descendents);
      getKids(MCParticleVector,_fGamma2_id,Gamma2_descendents);

      for(auto const& mcpart : TwoGammaV){
	  
	if(mcpart->TrackId() == _fGamma1_id){
	  _fGamma1_DirX = mcpart->Px()/mcpart->P();
	  _fGamma1_DirY = mcpart->Py()/mcpart->P();
	  _fGamma1_DirZ = mcpart->Pz()/mcpart->P();
	}
	  
	if(mcpart->TrackId() == _fGamma2_id){
	  _fGamma2_DirX = mcpart->Px()/mcpart->P();
	  _fGamma2_DirY = mcpart->Py()/mcpart->P();
	  _fGamma2_DirZ = mcpart->Pz()/mcpart->P();
	}
	  
      }

      _fGamma12_CosTheta = _fGamma1_DirX*_fGamma2_DirX + _fGamma1_DirY*_fGamma2_DirY + _fGamma1_DirZ*_fGamma2_DirZ;
      _fGamma12_Angle = radToDeg(std::acos(_fGamma12_CosTheta));

      _fPi0M = pi0Mass(_fGamma1_E,_fGamma2_E,_fGamma12_CosTheta);  

    }//signal

    _fNpi0 = Npi0;
    _fNmuon = Nmuon;
    _fNpiplus = Npiplus;
    _fNproton = Nproton;
    _fNneutron = Nneutron;
    
  }//fIsMC

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////// EVENT WEIGHTS //////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  double cvweight = 1.;

  double dirt_avgsplineweight = 1.;
  double dirt_avgcvweight = 1.;
  double dirt_weight = 1.;
  if(fIsDirt){

    art::Handle<std::vector<evwgh::MCEventWeight>> EventWeightHandle;
    e.getByLabel(fEventWeightTag, EventWeightHandle);
    std::vector<art::Ptr<evwgh::MCEventWeight>> EventWeightVector;
    art::fill_ptr_vector(EventWeightVector, EventWeightHandle);
     
    if(EventWeightVector.size() > 0){
      art::Ptr<evwgh::MCEventWeight> dirt_evt_wgt = EventWeightVector.at(0);

      for (auto entry : dirt_evt_wgt->fWeight) {
	  
	if(entry.first == "TunedCentralValue_Genie"){
	  float sum = 0; int nsum = 0;
	  for(auto const & sec : entry.second){
	    if(sec >= 0 && sec <= 10000.){
	      sum += sec;
	      nsum++;
	    }
	  }
	  if(nsum != 0){dirt_avgcvweight = sum/float(nsum);}
	}//cv

	if(entry.first == "splines_general_Spline"){
	  float sum = 0; int nsum = 0;
	  for(auto const & sec : entry.second){
	    if(sec >= 0 && sec <= 10000.){
	      sum += sec;
	      nsum++;
	    }
	  }
	  if(nsum != 0){dirt_avgsplineweight = sum/float(nsum);}
	}//spline
	
      }//eventweight

      dirt_weight = dirt_avgcvweight*dirt_avgsplineweight;
      if(_fResNum == 17 || _fResNum == 9){dirt_weight = 0;}

      std::cout<<"DIRT WEIGHT! "<<dirt_weight<<std::endl;
      
    }//eventweightvector
  }//fIsDirt

  double mc_splineweight = 1.;
  double mc_cvweight = 1.;
  double mc_weight = 1.;
  if(fIsMC){

    art::Handle<std::vector<evwgh::MCEventWeight>> EventWeightHandle;
    e.getByLabel(fEventWeightTag, EventWeightHandle);
    std::vector<art::Ptr<evwgh::MCEventWeight>> EventWeightVector;
    art::fill_ptr_vector(EventWeightVector, EventWeightHandle);
    
    if (EventWeightVector.size() > 0) {
      art::Ptr<evwgh::MCEventWeight> evt_wgt = EventWeightVector.at(0);

      for (auto entry : evt_wgt->fWeight) {

	std::cout<<"WEIGHT MAPS! "<<entry.first<<std::endl;
	  
	if(entry.first == "TunedCentralValue_Genie"){
	  if(entry.second.at(0) >= 0 && entry.second.at(0) <= 100000.){mc_cvweight = entry.second.at(0);}
	}//cv

	if(entry.first == "splines_general_Spline"){
	  if(entry.second.at(0) >= 0 && entry.second.at(0) <= 100000.){mc_splineweight = entry.second.at(0);}
	}//spline

      }//eventweight

      mc_weight = mc_cvweight*mc_splineweight;
      if(_fResNum == 17 || _fResNum == 9){mc_weight = 0;}
     
      ///////////////////////////////////////////////////////////////////////////////////////////////////////////
      //////////////////////////////// STORE EVENT WEIGHTS FOR SYSTEMATIC UNCERTAINTIES /////////////////////////
      ///////////////////////////////////////////////////////////////////////////////////////////////////////////
      
      for (auto entry : evt_wgt->fWeight) {

	if(_fResNum == 17 || _fResNum == 9) continue;

	///////////////// cross-section knobs /////////////////////////////

	//1
	if(entry.first == "All_Genie"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_All_Genie_Weights.push_back(sysweight);
	  }
	}

	//2
	if(entry.first == "RPA_CCQE_Genie"){
	  for(int i = 0; i < 2; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_RPA_CCQE_Genie_Weights.push_back(sysweight);
	  }
	}

	//3
	if(entry.first == "XSecShape_CCMEC_Genie"){
	  for(int i = 0; i < 2; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_XSecShape_CCMEC_Genie_Weights.push_back(sysweight);
	  }
	}

	//4
	if(entry.first == "AxFFCCQEshape_Genie"){
	  for(int i = 0; i < 2; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_AxFFCCQEshape_Genie_Weights.push_back(sysweight);
	  }
	}

	//5
	if(entry.first == "VecFFCCQEshape_Genie"){
	  for(int i = 0; i < 2; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_VecFFCCQEshape_Genie_Weights.push_back(sysweight);
	  }
	}

	//6
	if(entry.first == "DecayAngMEC_Genie"){
	  for(int i = 0; i < 2; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_DecayAngMEC_Genie_Weights.push_back(sysweight);
	  }
	}

	//7
	if(entry.first == "Theta_Delta2Npi_Genie"){
	  for(int i = 0; i < 2; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_Theta_Delta2Npi_Genie_Weights.push_back(sysweight);
	  }
	}

	///////////////// flux knobs /////////////////////////////

	//1
	if(entry.first == "expskin_FluxUnisim"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_expskin_FluxUnisim_Weights.push_back(sysweight);
	  }
	}//flux1

	//2
	if(entry.first == "horncurrent_FluxUnisim"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_horncurrent_FluxUnisim_Weights.push_back(sysweight);
	  }
	}//flux2

	//3
	if(entry.first == "kminus_PrimaryHadronNormalization"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_kminus_PrimaryHadronNormalization_Weights.push_back(sysweight);
	  }
	}//flux3

	//4
	if(entry.first == "kplus_PrimaryHadronFeynmanScaling"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_kplus_PrimaryHadronFeynmanScaling_Weights.push_back(sysweight);
	  }
	}//flux4

	//5
	if(entry.first == "kzero_PrimaryHadronSanfordWang"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_kzero_PrimaryHadronSanfordWang_Weights.push_back(sysweight);
	  }
	}//flux5

	//6
	if(entry.first == "nucleoninexsec_FluxUnisim"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_nucleoninexsec_FluxUnisim_Weights.push_back(sysweight);
	  }
	}//flux6

	//7
	if(entry.first == "nucleonqexsec_FluxUnisim"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_nucleonqexsec_FluxUnisim_Weights.push_back(sysweight);
	  }
	}//flux7

	//8
	if(entry.first == "nucleontotxsec_FluxUnisim"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_nucleontotxsec_FluxUnisim_Weights.push_back(sysweight);
	  }
	}//flux8

	//9
	if(entry.first == "piminus_PrimaryHadronSWCentralSplineVariation"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_piminus_PrimaryHadronSWCentralSplineVariation_Weights.push_back(sysweight);
	  }
	}//flux9

	//10
	if(entry.first == "pioninexsec_FluxUnisim"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_pioninexsec_FluxUnisim_Weights.push_back(sysweight);
	  }
	}//flux10

	//11
	if(entry.first == "pionqexsec_FluxUnisim"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_pionqexsec_FluxUnisim_Weights.push_back(sysweight);
	  }
	}//flux11

	//12
	if(entry.first == "piontotxsec_FluxUnisim"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_piontotxsec_FluxUnisim_Weights.push_back(sysweight);
	  }
	}//flux12

	//13
	if(entry.first == "piplus_PrimaryHadronSWCentralSplineVariation"){
	  for(int i = 0; i < 100; i++){
	    double sysweight = 1.;
	    if(entry.second.at(i) >= 0 && entry.second.at(i) <= 100000.){sysweight = entry.second.at(i)*mc_splineweight;}
	    _f_piplus_PrimaryHadronSWCentralSplineVariation_Weights.push_back(sysweight);
	  }
	}//flux13
	
      }//systematics event weights loop

    }//event has weights

  }//fIsMC

  if(fIsDirt){cvweight = dirt_weight;}
  if(fIsMC){cvweight = mc_weight;}
  _fCVWeight = cvweight;

  std::cout<<"CVWEIGHT! "<<_fCVWeight<<std::endl;
  			       
    
  //////////////////////////////////////////////////// DETECTOR /////////////////////////////////////////////
  auto const TPC = (*geom).begin_TPC();
  auto ID = TPC.ID();
  m_Cryostat = ID.Cryostat;
  m_TPC = ID.TPC;
  _time2cm = theDetector->SamplingRate() / 1000.0 * theDetector->DriftVelocity( theDetector->Efield(), theDetector->Temperature() );//found in ProtoShowerPandora_tool.cc
  
  std::cout<<"Test event loop with m_TPC = "<<m_TPC<<" m_Cryostat = "<<m_Cryostat<<" _time2cm = "<<_time2cm<<std::endl;
  
  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////// FLASH INFORMATION ////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  double maxPE = -99999.;
  std::vector<art::Ptr<recob::OpFlash> > maxFlash;
  for(auto const & flash : OpFlashVector){
    if(flash->TotalPE() > maxPE){maxPE = flash->TotalPE();}
  }
  for(auto const & flash : OpFlashVector){
    if(flash->TotalPE() == maxPE){maxFlash.push_back(flash);}
  }
  if(maxFlash.size() == 1){
    for(auto const & flash : maxFlash){
      _fFlashTime = flash->Time();
      _fFlashTimeWidth = flash->TimeWidth();
      _fFlashAbsTime = flash->AbsTime();
      _fFlashTotalPE = flash->TotalPE();
      _fFlashYCenter = flash->YCenter();
      _fFlashYWidth = flash->YWidth();
      _fFlashZCenter = flash->ZCenter();
      _fFlashZWidth = flash->ZWidth();
    }
  }
 

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////// NEUTRINO PFPARTICLES /////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  //NEUTRINO-INDUCED PFPARTICLES
  std::cout<<"FOUND "<<PFParticleVector.size()<<" PFPARTICLES! "<<std::endl;
  std::vector<art::Ptr<recob::PFParticle> > nuPFParticles;
  std::vector<art::Ptr<recob::PFParticle> > nuVertexPFP;

  //Get neutrino slice, and children of primary neutrino pfp
  for(auto const& pfp : PFParticleVector){
    
    //GET NEUTRINO PFP
    if(pfp->IsPrimary() && std::abs(pfp->PdgCode()) == 14){
      nuVertexPFP.push_back(pfp);
    }//neutrino slice
    
    bool isNuChild = false;
    if(pfp->IsPrimary())
      continue;
    
    auto parent = pfp->Parent();
    
    for(auto const& pfp_parent : PFParticleVector){
      if(pfp_parent->Self() != parent)
  	continue;
      if(!pfp_parent->IsPrimary())
  	continue;
      if(std::abs(pfp_parent->PdgCode()) != 12 && std::abs(pfp_parent->PdgCode()) != 14 && std::abs(pfp_parent->PdgCode()) != 16)
  	continue;
      isNuChild = true;
    }
    
    if(isNuChild == true){
      nuPFParticles.push_back(pfp);
    }
    
  }//pfparticle loop

  //Pass only neutrino events
  if(nuVertexPFP.size() == 1){

    /////////////////////////////////////////////////
    ///////// CANDIDATE NEUTRINO VERTEX /////////////
    /////////////////////////////////////////////////
    
    art::FindManyP<recob::Vertex> pfPartToVertexAssoc(PFParticleHandle, e, "pandora");
    art::FindManyP<anab::T0> nupfPartToT0Assoc(PFParticleHandle, e, "flashmatch");
    
    for(auto const& pfp : nuVertexPFP){
      const auto associatedVertex = pfPartToVertexAssoc.at(pfp.key());
  
      if (associatedVertex.size() > 0){
	for(size_t i = 0; i < associatedVertex.size(); i++){
	  auto const vtx = associatedVertex[i];
	  nuVertex.push_back(vtx);
	}
      }//associated vertices

      //////////////// FLASH CHI2 ////////////////////
      const std::vector<art::Ptr<anab::T0>> T0_flashchi_v = nupfPartToT0Assoc.at(pfp.key()); //pfPartToT0Assoc.at(pfp.key());
      
      if(T0_flashchi_v.size() == 1){
	flashchi2 = T0_flashchi_v.at(0)->TriggerConfidence();
	flashchi2weight = getFlashChi2Weight(flashchi2);
	flashnewchi2weight = getNewFlashChi2Weight(flashchi2);
	std::cout<<"OUT_OF_THE_BOX FLASH CHI2 = "<<flashchi2<<" WEIGHT = "<<flashchi2weight<<std::endl;
	
      }//associated T0
      
    }//nupfp

   
    if(flashchi2weight >= 0){_fFlashChi2Weight = flashchi2weight;}
    if(flashnewchi2weight >= 0){_fFlashNewChi2Weight = flashnewchi2weight;}
    _fFlashChi2 = flashchi2;
    
    std::cout<<"CHECK FLASH CHI2 = "<<_fFlashChi2<<"  "<<_fFlashChi2Weight<<std::endl;
    
    std::cout<<"HEY! FINALLY FOUND "<<nuVertex.size()<<" CANDIDATE VERTICES!"<<std::endl;

    /////////////////////////////////////////////////
    ///////// CANDIDATE MUON TRACK ///////////////////
    /////////////////////////////////////////////////

    //Find tracks & showers associated with neutrino pfp
    art::FindManyP<larpandoraobj::PFParticleMetadata> pfPartToMetaDataAssoc(PFParticleHandle, e, "pandora");
    art::FindManyP<recob::Track> pfPartToTrackAssoc(PFParticleHandle, e, "pandora");
    art::FindManyP<anab::T0> pfPartToT0Assoc(PFParticleHandle, e, "NuCCproducer");
    
    for(auto const& pfp : nuPFParticles){
      const std::vector<art::Ptr<anab::T0>> T0_muon = pfPartToT0Assoc.at(pfp.key());
      std::cout<<"HEY! THIS DAUGHTER PFPARTICLE HAS "<<T0_muon.size()<<" ASSOCIATED MUON T0 INFO! "<<std::endl;

      if(T0_muon.size() == 1){
	const auto associatedTracks = pfPartToTrackAssoc.at(pfp.key()); //tracks associated with candidate muon pfp

	if(associatedTracks.size() == 0){std::cout<<"HEY! THE CANDIDATE MUON PFP HAS NO ASSOCIATED TRACKS!"<<std::endl;}
	if(associatedTracks.size() > 1){std::cout<<"HEY! THE CANDIDATE MUON PFP HAS MANY ASSOCIATED TRACKS!"<<std::endl;}
	if(associatedTracks.size() == 1){
	  for(size_t i = 0; i < associatedTracks.size(); i++){
	    auto const tr = associatedTracks[i];
	    nuMuon.push_back(tr);
	    
	  }//associated track
	}//1 associated track
      }//is candidate muon pfp
    }//neutrino daughters

    std::cout<<"HEY! THIS EVENT HAS "<<nuMuon.size()<<" CANDIDATE MUON TRACKS!"<<std::endl;

    /////////// PASS ONLY CC INCLUSIVE FILTERED EVENTS
    if(nuVertex.size() == 1 && nuMuon.size() == 1){

      for(auto const& vtx : nuVertex){
	const recob::Vertex::Point_t &neutrino_vtx = vtx->position(); 
	auto VertexOffset = SCE->GetCalPosOffsets(geo::Point_t(neutrino_vtx.X(), neutrino_vtx.Y(), neutrino_vtx.Z()));

	VertexX = neutrino_vtx.X() - VertexOffset.X();
	VertexY = neutrino_vtx.Y() + VertexOffset.Y();
	VertexZ = neutrino_vtx.Z() + VertexOffset.Z();
  
      }//nuvtx

      auto muonTrack = nuMuon.front();
      MuonID = muonTrack->ID();
      MuonCostheta = std::cos(muonTrack->Theta());
      MuonPhi = muonTrack->Phi();

      auto muonVertexOffset = SCE->GetCalPosOffsets(geo::Point_t(muonTrack->Vertex().X(), muonTrack->Vertex().Y(), muonTrack->Vertex().Z()));
      auto muonVertexEndOffset = SCE->GetCalPosOffsets(geo::Point_t(muonTrack->End().X(), muonTrack->End().Y(), muonTrack->End().Z()));

      double muonVertexX = muonTrack->Vertex().X() - muonVertexOffset.X();
      double muonVertexY = muonTrack->Vertex().Y() + muonVertexOffset.Y();
      double muonVertexZ = muonTrack->Vertex().Z() + muonVertexOffset.Z();

      double muonVertexEndX = muonTrack->End().X() - muonVertexEndOffset.X();
      double muonVertexEndY = muonTrack->End().Y() + muonVertexEndOffset.Y();
      double muonVertexEndZ = muonTrack->End().Z() + muonVertexEndOffset.Z();
     
      MuonLength = std::sqrt(std::pow(muonVertexX - muonVertexEndX,2) + std::pow(muonVertexY - muonVertexEndY,2) + std::pow(muonVertexZ - muonVertexEndZ,2));

      int muonbestplane = bestPlane(fmht.at(muonTrack.key()));
      MuonBestPlane = muonbestplane;
   
      std::cout<<MuonID<<std::endl;

      trkf::TrackMomentumCalculator tmc;
      MuonMCSMomentum = (MCSFitResultVector.at(muonTrack.key())->bestMomentum())*1000;
      MuonRangeMomentum = 1000*tmc.GetTrackMomentum(MuonLength,13);
		
      float startdist = std::sqrt(std::pow(muonVertexX - VertexX,2) + std::pow(muonVertexY - VertexY,2) + std::pow(muonVertexZ - VertexZ,2));
      float enddist = std::sqrt(std::pow(muonVertexEndX - VertexX,2) + std::pow(muonVertexEndY - VertexY,2) + std::pow(muonVertexEndZ - VertexZ,2));
      if(startdist <= enddist){
	MuonStartX = muonVertexX;
	MuonStartY = muonVertexY;
	MuonStartZ = muonVertexZ;
	MuonEndX = muonVertexEndX;
	MuonEndY = muonVertexEndY;
	MuonEndZ = muonVertexEndZ;
      }
      if(startdist > enddist){
	MuonEndX = muonVertexX;
	MuonEndY = muonVertexY;
	MuonEndZ = muonVertexZ;
	MuonStartX = muonVertexEndX;
	MuonStartY = muonVertexEndY;
	MuonStartZ = muonVertexEndZ;
      }

      MuonDist3d = std::min(startdist,enddist);
      MuonAng3d = trackRadialAngle(muonTrack,VertexX,VertexY,VertexZ);

      std::cout<<"MUON RADIAL ANGLE "<<MuonAng3d<<std::endl;
	
      if(inFV(muonVertexX,muonVertexY,muonVertexZ) == true && inFV(muonVertexEndX,muonVertexEndY,muonVertexEndZ) == true){
	MuonIsContained = 1;
	MuonMomentum = MuonRangeMomentum;
      }
	
      if(inFV(muonVertexX,muonVertexY,muonVertexZ) == false || inFV(muonVertexEndX,muonVertexEndY,muonVertexEndZ) == false){
	MuonIsContained = 0;
	MuonMomentum = MuonMCSMomentum;
      }

      if(fIsMC){
	MuonComposition = getTrueTrackComposition(e, fHitTag, HitVector, fmht.at(muonTrack.key()), MCParticleVector, fHitPartAssnTag, 2);
	if(_fNuInFV == 1 && std::abs(_fNuPDG) == 14 && _fNuCCNC == 0 && Npi0 == 1 && Nmuon == 1 && Npiplus == 0){
	  MuonAngleBiasCosine = muonAngleBias(VertexX,VertexY,VertexZ,_fLepPx, _fLepPy, _fLepPz, _fLepP, MuonMomentum, muonTrack);
	  MuonAngleBiasDegrees = cosineToDeg(MuonAngleBiasCosine);
	  MuonMCSMomentumBias = muonMomentumBias(_fLepP, MuonMCSMomentum);
	  MuonRangeMomentumBias = muonMomentumBias(_fLepP, MuonRangeMomentum);
	  MuonMomentumBias = muonMomentumBias(_fLepP, MuonMomentum);
	}//signal
      }//fIsMC
      
    }//ccinc

    _fCandidateMuonComposition = MuonComposition;
    _fCandidateMuonMCSMomentumBias = MuonMCSMomentumBias;
    _fCandidateMuonRangeMomentumBias = MuonRangeMomentumBias;
    _fCandidateMuonMomentumBias = MuonMomentumBias;
    _fCandidateMuonAngleBiasCosine = MuonAngleBiasCosine;
    _fCandidateMuonAngleBiasDegrees = MuonAngleBiasDegrees;
    _fCandidateVertexX = VertexX;
    _fCandidateVertexY = VertexY;
    _fCandidateVertexZ = VertexZ;
    _fCandidateMuonStartX = MuonStartX;
    _fCandidateMuonStartY = MuonStartY;
    _fCandidateMuonStartZ = MuonStartZ;
    _fCandidateMuonEndX = MuonEndX;
    _fCandidateMuonEndY = MuonEndY;
    _fCandidateMuonEndZ = MuonEndZ;
    _fCandidateMuonMomentum = MuonMomentum;
    _fCandidateMuonMCSMomentum = MuonMCSMomentum;
    _fCandidateMuonRangeMomentum = MuonRangeMomentum;
    _fCandidateMuonLength = MuonLength;
    _fCandidateMuonCostheta = MuonCostheta;
    _fCandidateMuonPhi = MuonPhi;
    _fCandidateMuonIsContained = MuonIsContained;
    _fCandidateMuonBestPlane = MuonBestPlane;
    _fCandidateMuonDist3d = MuonDist3d;
    _fCandidateMuonAng3d = MuonAng3d;
  
    for(auto const& pfp : nuPFParticles){
      const auto associatedTracks = pfPartToTrackAssoc.at(pfp.key());
      const auto associatedShowers = pfPartToShowerAssoc.at(pfp.key());
      const auto associatedMetaData = pfPartToMetaDataAssoc.at(pfp.key());
      const auto associatedTrackFitter = trackFitterAssoc.at(pfp.key());     
	
      float score = -999;
	
      //Associated metadata
      if(associatedMetaData.empty()){
	std::cout<<" PFParticle has no metadata!!!"<<std::endl;
      }
      if(associatedMetaData.size() > 1){
	std::cout<<" PFParticle has >1 metadata!!!"<<std::endl;
      }
      if(!associatedMetaData.empty()){
	if(associatedMetaData.size() == 1){
	  const auto metaMap = associatedMetaData.at(0)->GetPropertiesMap();
	  const auto scoreMap = metaMap.find("TrackScore");
	  score = scoreMap->second;
	    
	}
      }
	
      //Associated tracks
      if (associatedTracks.size() > 1){
	std::cout << "PFParticle has >1 track!" << std::endl;
      }
      if (associatedTracks.size() > 0){
	for(size_t i = 0; i < associatedTracks.size(); i++){
	  auto const tr = associatedTracks[i];
	  nuTracks.push_back(tr);
	  nuTracks_ScoreMap[tr] = score;
	  std::cout<<"PFP MATCHED TO TRACK!! SCORE = "<<score<<std::endl;
	}
      }
	
      //Associated showers
      if (associatedShowers.size() > 1){
	std::cout << "PFParticle has >1 shower!" << std::endl;
      }
      if (associatedShowers.size() > 0){
	for(size_t i = 0; i < associatedShowers.size(); i++){
	  auto const sh = associatedShowers[i];
	  nuShowers.push_back(sh);
	  nuShowers_ScoreMap[sh] = score;
	  std::cout<<"PFP MATCHED TO SHOWER!! SCORE = "<<score<<std::endl;
	}
      }
	
      //Associate track fitter to shower
      if(associatedShowers.size() == 1 && associatedTrackFitter.size() == 1){
	  
	std::cout<<"FOUND EXACTLY ONE SHOWER AND ONE TRACK FITTER ASSOCIATED WITH THIS PFPARTICLE!"<<std::endl;
	  
	for(size_t i = 0; i < associatedShowers.size(); i++){
	  auto const sh = associatedShowers[i];
	    
	  for(size_t i = 0; i < associatedTrackFitter.size(); i++){
	    auto const trk = associatedTrackFitter[i];
	    int ID = trk->ID();
	      
	    nuShowerTrackMap[sh] = ID;
	      
	  }//track fitter
	    
	}//shower
	  
      }
	
    }//nupfp

  }//has neutrino

  int nhitsu = 0;
  int nhitsv = 0;
  int nhitsy = 0;
  for(auto const & hit : HitVector){
    int plane = hit->View();
    if(plane == 0){nhitsu++;}
    if(plane == 1){nhitsv++;}
    if(plane == 2){nhitsy++;}
  }
  _fNHitsU = nhitsu;
  _fNHitsV = nhitsv;
  _fNHitsY = nhitsy;
  _fNTracks = nuTracks.size();
  _fNShowers = nuShowers.size();
  if(nuVertex.size() == 1){_fHasCandidateNeutrino = 1;} else{_fHasCandidateNeutrino = 0;}
  if(nuMuon.size() == 1){_fHasCandidateMuon = 1;} else{_fHasCandidateMuon = 0;}

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////// CC PI0 SELECTION CUTS ///////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  ////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////// CHARGED PION VETO /////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////

  art::FindMany<anab::ParticleID> fmpid(TrackHandle, e, "pandoracalipidSCE");
  
  for(auto const& track : nuTracks){

    auto trackVertexOffset = SCE->GetCalPosOffsets(geo::Point_t(track->Vertex().X(), track->Vertex().Y(), track->Vertex().Z()));
    auto trackVertexEndOffset = SCE->GetCalPosOffsets(geo::Point_t(track->End().X(), track->End().Y(), track->End().Z()));

    double trackVertexX = track->Vertex().X() - trackVertexOffset.X();
    double trackVertexY = track->Vertex().Y() + trackVertexOffset.Y();
    double trackVertexZ = track->Vertex().Z() + trackVertexOffset.Z();

    double trackVertexEndX = track->End().X() - trackVertexEndOffset.X();
    double trackVertexEndY = track->End().Y() + trackVertexEndOffset.Y();
    double trackVertexEndZ = track->End().Z() + trackVertexEndOffset.Z();
     
    double length = std::sqrt(std::pow(trackVertexX - trackVertexEndX,2) + std::pow(trackVertexY - trackVertexEndY,2) + std::pow(trackVertexZ - trackVertexEndZ,2));
    std::cout<<length<<std::endl;

    //Find 3-plane PID
    float chi2 = 99999999999;
    if(fmpid.isValid()){
      std::vector<const anab::ParticleID*> pids = fmpid.at(track.key());
      for (size_t ipid=0; ipid < pids.size(); ipid++){
	std::vector<anab::sParticleIDAlgScores> AlgScoresVec = pids[ipid]->ParticleIDAlgScores();
	for (size_t i_algscore=0; i_algscore < AlgScoresVec.size(); i_algscore++){
	  anab::sParticleIDAlgScores AlgScore = AlgScoresVec.at(i_algscore);
	  //Get 3-plane pid
	  if (AlgScore.fAlgName == "ThreePlaneProtonPID"){
	    if (anab::kVariableType(AlgScore.fVariableType) == anab::kLikelihood){
	      chi2 = std::log(AlgScore.fValue);		
	    }//has chi2
	  }//3-plane pid
	}//end loop though AlgScoresVec
      }//end loop over pid[ipid]
    }// fmpid.isValid()

    float startdist = std::sqrt(std::pow(trackVertexX - VertexX,2) + std::pow(trackVertexY - VertexY,2) + std::pow(trackVertexZ - VertexZ,2));
    float enddist = std::sqrt(std::pow(trackVertexEndX - VertexX,2) + std::pow(trackVertexEndY - VertexY,2) + std::pow(trackVertexEndZ - VertexZ,2));
    float dist_from_vertex = std::min(startdist,enddist);
  
    //Avoid candidate muon
    if(track->ID() == MuonID){ MuonPID = chi2; continue;}
    //Avoid tracks starting away from vertex, i.e. cosmics or EM stuff
    if(dist_from_vertex > 4.) continue;
    //Avoid protons
    if(chi2 > -0.9 && inFV(trackVertexX,trackVertexY,trackVertexZ) == true && inFV(trackVertexEndX,trackVertexEndY,trackVertexEndZ) == true && length < MuonLength) continue;
    //Absolute PID cut
    if(chi2 > -0.9) continue;
    nchargedpicand++;

  }//track loop
 
  _fCandidateMuonPID = MuonPID;

  std::cout<<nchargedpicand<<std::endl;

  ////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// CHOOSE PHOTON CANDIDATES //////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////

  for(auto const& shower : nuShowers) {
    double dist3d = conversionDistance(shower, VertexX, VertexY, VertexZ);
    double ang3d = radialAngle(shower, VertexX, VertexY, VertexZ);
    double energy2 = (showerEnergy(2, fmhs.at(shower.key())));
    
    //lead candidate selection
    if((dist3d > 6. && dist3d < 82.) || (energy2 > 50 && energy2 < 300 && dist3d < 6)){
      LeadCandidatesCL.push_back(shower);
      if(energy2 > 50){
	LeadCandidatesEN.push_back(shower);
	if(ang3d > 0.96){
	  LeadCandidatesRA.push_back(shower);
	  LeadCandidates.push_back(shower);
	}
      }
    }
  }//showers

  //FIND LEAD CANDIDATE
  int lead_id = 0;
  float lead_energy = -999.;
  for(auto const& shower : LeadCandidates){
    int id = shower->ID();
    float energy = showerEnergy(2, fmhs.at(shower.key()));
    if(energy > lead_energy){
      lead_energy = energy;
      lead_id = id;
    }//max energy
  }//lead loop
  for(auto const& shower : LeadCandidates){
    if(shower->ID() == lead_id){TheLeadVector.push_back(shower);}
  }
  
  //FIND SUBLEAD CANDIDATES
  for(auto const& shower : nuShowers){
    int id = shower->ID();
    double dist3d = conversionDistance(shower, VertexX, VertexY, VertexZ);
    float energy2 = showerEnergy(2, fmhs.at(shower.key()));
     
    if(id == lead_id) continue;

    if(dist3d > 1){
      SubleadCandidatesCL.push_back(shower);
      if(energy2 > 25){
	SubleadCandidatesEN.push_back(shower);
	SubleadCandidates.push_back(shower);
      }//energy
    }//dist3d
	
  }//showers
  
  ////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// MASS CUT TO MATCH PHOTONS /////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////

  if(TheLeadVector.size() == 1){
    auto thelead = TheLeadVector.front();
    double leadenergy = (showerEnergy(2, fmhs.at(thelead.key())))/yplanebias;
   
    //Sublead
    for(auto const& sublead : SubleadCandidates){
      double subleadenergy = (showerEnergy(2, fmhs.at(sublead.key())))/yplanebias;
      double angle12 = angleBetweenTwoShowers(thelead,sublead);
      double pi0mass = pi0Mass(leadenergy,subleadenergy,angle12);
      _fCandidatePi0Mass.push_back(pi0mass);
      if(pi0mass > 60 && pi0mass < 180){
	npairs++;
	TheSubleadVector.push_back(sublead);
      }
    }//sublead loop

    /////////// AVOID OTHER PHOTON PAIRS FROM PI0 /////////////
	
    if(npairs == 1){

      auto sublead1 = TheSubleadVector.front();
      auto subleadid1 = sublead1->ID();

      /////// PATH 2: Check for other actual lead-sublead pairs ///////////

      for(auto const& shower : SubleadCandidates){
	auto showerid = shower->ID();
	double dist3d = conversionDistance(shower, VertexX, VertexY, VertexZ);
	double ang3d = radialAngle(shower, VertexX, VertexY, VertexZ);

	double energy2 = (showerEnergy(2, fmhs.at(shower.key())));
	double showerenergy = (showerEnergy(2, fmhs.at(shower.key())))/yplanebias;
	    
	if(showerid == subleadid1) continue;

	for(auto const& shower2 : SubleadCandidates){
	  auto showerid2 = shower2->ID();
	  double dist3d2 = conversionDistance(shower2, VertexX, VertexY, VertexZ);
	  double ang3d2 = radialAngle(shower2, VertexX, VertexY, VertexZ);

	  double energy22 = (showerEnergy(2, fmhs.at(shower2.key())));
	  double showerenergy2 = (showerEnergy(2, fmhs.at(shower2.key())))/yplanebias;

	  if(showerid2 == showerid || showerid2 == subleadid1 || showerenergy2 > showerenergy) continue;

	  if((((dist3d > 6. && dist3d < 82.) || (energy2 > 50 && energy2 < 300 && dist3d < 6)) && (energy2 > 50) && (ang3d > 0.96)) || (((dist3d2 > 6. && dist3d2 < 82.) || (energy22 > 50 && energy22 < 300 && dist3d2 < 6)) && (energy22 > 50) && (ang3d2 > 0.96))){

	    double angle12 = angleBetweenTwoShowers(shower,shower2);
	    double pi0mass = pi0Mass(showerenergy,showerenergy2,angle12);
		
	    if(pi0mass > 60 && pi0mass < 180){
	      notherfancypairs++;
	    }
	  }//one is a lead

	      
	}//loop2

      }//loop1

    }//1 pair

  }//1 lead vector

  _fNChargedPiCandidates = nchargedpicand;
  _fNLeadCandidates = LeadCandidates.size();
  _fNSubleadCandidates = SubleadCandidates.size();
  _fNPairCandidates = npairs;
  _fNOtherFancyPairs = notherfancypairs;

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //CCINCLUSIVE
  if(nuVertexPFP.size() == 1 && nuVertex.size() == 1 && nuMuon.size() == 1){

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////// TRACK DISTRIBUTIONS //////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    for(auto const& track : nuTracks){
      int trackcomposition = -999;
      if(fIsMC){
	trackcomposition = getTrueTrackComposition(e, fHitTag, HitVector, fmht.at(track.key()), MCParticleVector, fHitPartAssnTag, 2);
      }
      auto trackVertexOffset = SCE->GetCalPosOffsets(geo::Point_t(track->Vertex().X(), track->Vertex().Y(), track->Vertex().Z()));
      auto trackVertexEndOffset = SCE->GetCalPosOffsets(geo::Point_t(track->End().X(), track->End().Y(), track->End().Z()));
      double trackVertexX = track->Vertex().X() - trackVertexOffset.X();
      double trackVertexY = track->Vertex().Y() + trackVertexOffset.Y();
      double trackVertexZ = track->Vertex().Z() + trackVertexOffset.Z();
      double trackVertexEndX = track->End().X() - trackVertexEndOffset.X();
      double trackVertexEndY = track->End().Y() + trackVertexEndOffset.Y();
      double trackVertexEndZ = track->End().Z() + trackVertexEndOffset.Z();
      double length = std::sqrt(std::pow(trackVertexX - trackVertexEndX,2) + std::pow(trackVertexY - trackVertexEndY,2) + std::pow(trackVertexZ - trackVertexEndZ,2));
      double score = nuTracks_ScoreMap[track];
      double costheta = std::cos(track->Theta());
      double phi = track->Phi();
      double momentum = (MCSFitResultVector.at(track.key())->bestMomentum())*1000;
      double pid = -99999;
      double dist3d = -9999;
      double ang3d = -9999;
      int iscontained = -9999;
      double startx = -99999; double starty = -99999; double startz = -99999;
      double endx = -99999; double endy = -99999; double endz = -99999;
      float startdist = std::sqrt(std::pow(trackVertexX - VertexX,2) + std::pow(trackVertexY - VertexY,2) + std::pow(trackVertexZ - VertexZ,2));
      float enddist = std::sqrt(std::pow(trackVertexEndX - VertexX,2) + std::pow(trackVertexEndY - VertexY,2) + std::pow(trackVertexEndZ - VertexZ,2));
      if(startdist <= enddist){
	startx = trackVertexX;
	starty = trackVertexY;
	startz = trackVertexZ;
	endx = trackVertexEndX;
	endy = trackVertexEndY;
	endz = trackVertexEndZ;
      }
      if(startdist > enddist){
	startx = trackVertexEndX;
	starty = trackVertexEndY;
	startz = trackVertexEndZ;
	endx = trackVertexX;
	endy = trackVertexY;
	endz = trackVertexZ;
      }
      dist3d = std::min(startdist,enddist);
      ang3d = trackRadialAngle(track,VertexX,VertexY,VertexZ);
      std::cout<<"TRACK RADIAL ANGLE "<<ang3d<<std::endl;
      if(inFV(trackVertexX,trackVertexY,trackVertexZ) == true && inFV(trackVertexEndX,trackVertexEndY,trackVertexEndZ) == true){
	iscontained = 1;
      }

      if(inFV(trackVertexX,trackVertexY,trackVertexZ) == false || inFV(trackVertexEndX,trackVertexEndY,trackVertexEndZ) == false){
	iscontained = 0;
      }

      int trackbestplane = bestPlane(fmht.at(track.key()));
   
      //Find 3-plane PID
      if(fmpid.isValid()){
	std::vector<const anab::ParticleID*> pids = fmpid.at(track.key());
	for (size_t ipid=0; ipid < pids.size(); ipid++){
	  std::vector<anab::sParticleIDAlgScores> AlgScoresVec = pids[ipid]->ParticleIDAlgScores();
	  for (size_t i_algscore=0; i_algscore < AlgScoresVec.size(); i_algscore++){
	    anab::sParticleIDAlgScores AlgScore = AlgScoresVec.at(i_algscore);
	    //Get 3-plane pid
	    if (AlgScore.fAlgName == "ThreePlaneProtonPID"){
	      if (anab::kVariableType(AlgScore.fVariableType) == anab::kLikelihood){
		pid = std::log(AlgScore.fValue);		
	      }//has chi2
	    }//3-plane pid
	  }//end loop though AlgScoresVec
	}//end loop over pid[ipid]
      }// fmpid.isValid()

      _fTrackComposition.push_back(trackcomposition);
      _fTrackShowerScore.push_back(score);
      _fTrackBestPlane.push_back(trackbestplane);
      _fTrackIsContained.push_back(iscontained);
      _fTrackDist3d.push_back(dist3d);
      _fTrackAng3d.push_back(ang3d);
      _fTrackPID.push_back(pid);
      _fTrackStartX.push_back(startx);
      _fTrackStartY.push_back(starty);
      _fTrackStartZ.push_back(startz);
      _fTrackEndX.push_back(endx);
      _fTrackEndY.push_back(endy);
      _fTrackEndZ.push_back(endz);
      _fTrackMomentum.push_back(momentum);
      _fTrackLength.push_back(length);
      _fTrackCostheta.push_back(costheta);
      _fTrackPhi.push_back(phi);

    }//track loop

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////// SHOWER DISTRIBUTIONS /////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      
    for(auto const& shower : nuShowers){
      int comp = -999;
      double purity0 = -999; double purity1 = -999; double purity2 = -999; double purity3 = -999;
      double completeness0 = -999; double completeness1 = -999; double completeness2 = -999; double completeness3 = -999;
      double energybias0 = -999; double energybias1 = -999; double energybias2 = -999; double energybias3 = -999;

      int bestplane = bestPlane(fmhs.at(shower.key()));
      double energy0 = (showerEnergy(0, fmhs.at(shower.key())));
      double energy1 = (showerEnergy(1, fmhs.at(shower.key())));
      double energy2 = (showerEnergy(2, fmhs.at(shower.key())));
      double energy3 = (showerEnergy(bestplane, fmhs.at(shower.key())));

      if(fIsMC){
	if(_fNuInFV == 1 && std::abs(_fNuPDG) == 14 && _fNuCCNC == 0 && Npi0 == 1 && Nmuon == 1 && Npiplus == 0){

	  comp = getTrueComposition(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, Gamma1_descendents, Gamma2_descendents, fHitPartAssnTag, 2);

	  purity0 = getPurity(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 0);
	  purity1 = getPurity(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 1);
	  purity2 = getPurity(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 2);
	  purity3 = getPurity(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, bestplane);
	  
	  completeness0 = getComplete(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 0);
	  completeness1 = getComplete(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 1);
	  completeness2 = getComplete(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 2);
	  completeness3 = getComplete(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, bestplane);
	  energybias0 = getShowerBias(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, _fGamma1_E, _fGamma2_E, energy0, fHitPartAssnTag, 0);
	  energybias1 = getShowerBias(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, _fGamma1_E, _fGamma2_E, energy1, fHitPartAssnTag, 1);
	  energybias2 = getShowerBias(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, _fGamma1_E, _fGamma2_E, energy2, fHitPartAssnTag, 2);
	  energybias3 = getShowerBias(e, fHitTag, HitVector, fmhs.at(shower.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, _fGamma1_E, _fGamma2_E, energy3, fHitPartAssnTag, bestplane);

	}//signal
      }//fIsMC
      
      int trackID = nuShowerTrackMap[shower];
      double score = nuShowers_ScoreMap[shower];
      double length = shower->Length();
      double openangle = radToDeg(shower->OpenAngle());
      
      auto showerOffset = SCE->GetCalPosOffsets(geo::Point_t(shower->ShowerStart().X(), shower->ShowerStart().Y(), shower->ShowerStart().Z()));
      double startx = shower->ShowerStart().X() - showerOffset.X();
      double starty = shower->ShowerStart().Y() + showerOffset.Y();
      double startz = shower->ShowerStart().Z() + showerOffset.Z();

      double dirx = shower->Direction().X();
      double diry = shower->Direction().Y();
      double dirz = shower->Direction().Z();
      double costheta =  shower->Direction().Z();
      double phi =  std::atan(shower->Direction().Y()/shower->Direction().X());
      double thetaxz =  std::atan(shower->Direction().Z()/shower->Direction().X());
      double thetayz =  std::atan(shower->Direction().Z()/shower->Direction().Y());

      double dist3d = conversionDistance(shower, VertexX, VertexY, VertexZ);
      double ang3d = radialAngle(shower, VertexX, VertexY, VertexZ);

     
      double dedx0 = -999; double dedx1 = -999; double dedx2 = -999; double dedxamalg = -999; 
      getdEdx(e, fCaloTag, fShowerTag, fPFParticleTag, fTrackTag, fTrackFitterTag, fClusterTag, shower, nuPFParticles, TrackFitterVector, trackID, trunklength, trunkwidth, dedx0, dedx1, dedx2,dedxamalg);
      float bestdedx = -999.;
      if(bestplane == 0){
	bestdedx = dedx0;
      }
      if(bestplane == 1){
	bestdedx = dedx1;
      }
      if(bestplane == 2){
	bestdedx = dedx2;
      }

      _fShowerBestPlane.push_back(bestplane);
      _fTrackShowerScore.push_back(score);
      _fShowerLength.push_back(length);
      _fShowerOpenAngle.push_back(openangle);
      _fShowerDirX.push_back(dirx);
      _fShowerDirY.push_back(diry);
      _fShowerDirZ.push_back(dirz);
      _fShowerCostheta.push_back(costheta);
      _fShowerPhi.push_back(phi);
      _fShowerThetaXZ.push_back(thetaxz);
      _fShowerThetaYZ.push_back(thetayz);
      _fShowerDist3d.push_back(dist3d);
      _fShowerAng3d.push_back(ang3d);
      _fShowerStartX.push_back(startx);
      _fShowerStartY.push_back(starty);
      _fShowerStartZ.push_back(startz);
      _fShowerEnergy0.push_back(energy0);
      _fShowerEnergy1.push_back(energy1);
      _fShowerEnergy2.push_back(energy2);
      _fShowerEnergy3.push_back(energy3);
      _fShowerdEdx0.push_back(dedx0);
      _fShowerdEdx1.push_back(dedx1);
      _fShowerdEdx2.push_back(dedx2);
      _fShowerdEdx3.push_back(bestdedx);
      _fShowerComposition.push_back(comp);
      _fShowerPurity0.push_back(purity0);
      _fShowerPurity1.push_back(purity1);
      _fShowerPurity2.push_back(purity2);
      _fShowerPurity3.push_back(purity3);
      _fShowerCompleteness0.push_back(completeness0);
      _fShowerCompleteness1.push_back(completeness1);
      _fShowerCompleteness2.push_back(completeness2);
      _fShowerCompleteness3.push_back(completeness3);
      _fShowerEnergyBias0.push_back(energybias0);
      _fShowerEnergyBias1.push_back(energybias1);
      _fShowerEnergyBias2.push_back(energybias2);
      _fShowerEnergyBias3.push_back(energybias3);

    }//shower loop

     //Truth level object information
 
  }//ccinc

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////// SELECTED PI0 & GAMMA DISTRIBUTIONS ////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  if(nuVertexPFP.size() == 1 && nuVertex.size() == 1 && nuMuon.size() == 1 && nchargedpicand == 0 && nuShowers.size() >= 2 && TheLeadVector.size() == 1 && TheSubleadVector.size() == 1 && npairs == 1 && notherfancypairs == 0){
  
    auto leadcandidate = TheLeadVector.front();
    auto subleadcandidate = TheSubleadVector.front();

    int leadtrackID = nuShowerTrackMap[leadcandidate];
    double leadscore = nuShowers_ScoreMap[leadcandidate];
    double leadlength = leadcandidate->Length();
    double leadopenangle = radToDeg(leadcandidate->OpenAngle());
    auto leadOffset = SCE->GetCalPosOffsets(geo::Point_t(leadcandidate->ShowerStart().X(), leadcandidate->ShowerStart().Y(), leadcandidate->ShowerStart().Z()));
    double leadstartx = leadcandidate->ShowerStart().X() - leadOffset.X();
    double leadstarty = leadcandidate->ShowerStart().Y() + leadOffset.Y();
    double leadstartz = leadcandidate->ShowerStart().Z() + leadOffset.Z();
    double leaddirx = leadcandidate->Direction().X();
    double leaddiry = leadcandidate->Direction().Y();
    double leaddirz = leadcandidate->Direction().Z();
    double leadcostheta =  leadcandidate->Direction().Z();
    double leadphi =  std::atan(leadcandidate->Direction().Y()/leadcandidate->Direction().X());
    double leadthetaxz =  std::atan(leadcandidate->Direction().Z()/leadcandidate->Direction().X());
    double leadthetayz =  std::atan(leadcandidate->Direction().Z()/leadcandidate->Direction().Y());
    double leaddist3d = conversionDistance(leadcandidate, VertexX, VertexY, VertexZ);
    double leadang3d = radialAngle(leadcandidate, VertexX, VertexY, VertexZ);
    int leadbestplane = bestPlane(fmhs.at(leadcandidate.key()));
    double leadenergy = (showerEnergy(2, fmhs.at(leadcandidate.key())))/yplanebias;
    double leaddedx0 = -999; double leaddedx1 = -999; double leaddedx2 = -999; double leaddedxamalg = -999; 
    getdEdx(e, fCaloTag, fShowerTag, fPFParticleTag, fTrackTag, fTrackFitterTag, fClusterTag, leadcandidate, nuPFParticles, TrackFitterVector, leadtrackID, trunklength, trunkwidth, leaddedx0, leaddedx1, leaddedx2,leaddedxamalg);
    float leadbestdedx = -999.;
    if(leadbestplane == 0){
      leadbestdedx = leaddedx0;
    }
    if(leadbestplane == 1){
      leadbestdedx = leaddedx1;
    }
    if(leadbestplane == 2){
      leadbestdedx = leaddedx2;
    }

    int subleadtrackID = nuShowerTrackMap[subleadcandidate];
    double subleadscore = nuShowers_ScoreMap[subleadcandidate];
    double subleadlength = subleadcandidate->Length();
    double subleadopenangle = radToDeg(subleadcandidate->OpenAngle());
    auto subleadOffset = SCE->GetCalPosOffsets(geo::Point_t(subleadcandidate->ShowerStart().X(), subleadcandidate->ShowerStart().Y(), subleadcandidate->ShowerStart().Z()));
    double subleadstartx = subleadcandidate->ShowerStart().X() - subleadOffset.X();
    double subleadstarty = subleadcandidate->ShowerStart().Y() + subleadOffset.Y();
    double subleadstartz = subleadcandidate->ShowerStart().Z() + subleadOffset.Z();
    double subleaddirx = subleadcandidate->Direction().X();
    double subleaddiry = subleadcandidate->Direction().Y();
    double subleaddirz = subleadcandidate->Direction().Z();
    double subleadcostheta =  subleadcandidate->Direction().Z();
    double subleadphi =  std::atan(subleadcandidate->Direction().Y()/subleadcandidate->Direction().X());
    double subleadthetaxz =  std::atan(subleadcandidate->Direction().Z()/subleadcandidate->Direction().X());
    double subleadthetayz =  std::atan(subleadcandidate->Direction().Z()/subleadcandidate->Direction().Y());
    double subleaddist3d = conversionDistance(subleadcandidate, VertexX, VertexY, VertexZ);
    double subleadang3d = radialAngle(subleadcandidate, VertexX, VertexY, VertexZ);
    int subleadbestplane = bestPlane(fmhs.at(subleadcandidate.key()));
    double subleadenergy = (showerEnergy(2, fmhs.at(subleadcandidate.key())))/yplanebias;
    double subleaddedx0 = -999; double subleaddedx1 = -999; double subleaddedx2 = -999; double subleaddedxamalg = -999; 
    getdEdx(e, fCaloTag, fShowerTag, fPFParticleTag, fTrackTag, fTrackFitterTag, fClusterTag, subleadcandidate, nuPFParticles, TrackFitterVector, subleadtrackID, trunklength2, trunkwidth, subleaddedx0, subleaddedx1, subleaddedx2,subleaddedxamalg);
    float subleadbestdedx = -999.;
    if(subleadbestplane == 0){
      subleadbestdedx = subleaddedx0;
    }
    if(subleadbestplane == 1){
      subleadbestdedx = subleaddedx1;
    }
    if(subleadbestplane == 2){
      subleadbestdedx = subleaddedx2;
    }

    int leadmcid = -999;
    int leadcomp = -999;
    double leadpurity = -999;
    double leadcompleteness = -999;
    double leadenergybias = -999;
    double leadanglebiascosine = -999;
    double leadanglebiasdegrees = -999;

    int subleadmcid = -999;
    int subleadcomp = -999;
    double subleadpurity = -999;
    double subleadcompleteness = -999;
    double subleadenergybias = -999;
    double subleadanglebiascosine = -999;
    double subleadanglebiasdegrees = -999;
    
    if(fIsMC){
      if(_fNuInFV == 1 && std::abs(_fNuPDG) == 14 && _fNuCCNC == 0 && Npi0 == 1 && Nmuon == 1 && Npiplus == 0){

	leadmcid = getTrueParticleID(e, fHitTag, HitVector, fmhs.at(leadcandidate.key()), fHitPartAssnTag, 2);
	leadcomp = getTrueComposition(e, fHitTag, HitVector, fmhs.at(leadcandidate.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, Gamma1_descendents, Gamma2_descendents, fHitPartAssnTag, 2);
	leadpurity = getPurity(e, fHitTag, HitVector, fmhs.at(leadcandidate.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 2);
	leadcompleteness = getComplete(e, fHitTag, HitVector, fmhs.at(leadcandidate.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 2);
	leadenergybias = getShowerBias(e, fHitTag, HitVector, fmhs.at(leadcandidate.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, _fGamma1_E, _fGamma2_E, leadenergy, fHitPartAssnTag, 2);
	leadanglebiascosine = GammaAngleBias(leadmcid, MCParticleVector, _fGamma1_id, _fGamma2_id, _fGamma1_E, _fGamma2_E, _fGamma1_DirX, _fGamma1_DirY, _fGamma1_DirZ, _fGamma2_DirX, _fGamma2_DirY, _fGamma2_DirZ, leadenergy, leadcandidate);



	
	leadanglebiasdegrees = cosineToDeg(leadanglebiascosine);
	
	/////////

	subleadmcid = getTrueParticleID(e, fHitTag, HitVector, fmhs.at(subleadcandidate.key()), fHitPartAssnTag, 2);
	subleadcomp = getTrueComposition(e, fHitTag, HitVector, fmhs.at(subleadcandidate.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, Gamma1_descendents, Gamma2_descendents, fHitPartAssnTag, 2);
	subleadpurity = getPurity(e, fHitTag, HitVector, fmhs.at(subleadcandidate.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 2);
	subleadcompleteness = getComplete(e, fHitTag, HitVector, fmhs.at(subleadcandidate.key()), MCParticleVector, Gamma1_descendents, Gamma2_descendents, _fGamma1_id, _fGamma2_id, fHitPartAssnTag, 2);
	subleadenergybias = getShowerBias(e, fHitTag, HitVector, fmhs.at(subleadcandidate.key()), MCParticleVector, _fGamma1_id, _fGamma2_id, _fGamma1_E, _fGamma2_E, subleadenergy, fHitPartAssnTag, 2);
	subleadanglebiascosine = GammaAngleBias(subleadmcid, MCParticleVector, _fGamma1_id, _fGamma2_id, _fGamma1_E, _fGamma2_E, _fGamma1_DirX, _fGamma1_DirY, _fGamma1_DirZ, _fGamma2_DirX, _fGamma2_DirY, _fGamma2_DirZ, subleadenergy, subleadcandidate);
	subleadanglebiasdegrees = cosineToDeg(subleadanglebiascosine);
		
      }//signal
    }//fIsMC

    _fCandidateLeadScore = leadscore;
    _fCandidateLeadLength = leadlength;
    _fCandidateLeadOpenAngle = leadopenangle;
    _fCandidateLeadDirX = leaddirx;
    _fCandidateLeadDirY = leaddiry;
    _fCandidateLeadDirZ = leaddirz;
    _fCandidateLeadCostheta = leadcostheta;
    _fCandidateLeadPhi = leadphi;
    _fCandidateLeadThetaXZ = leadthetaxz;
    _fCandidateLeadThetaYZ = leadthetayz;
    _fCandidateLeadDist3d = leaddist3d;
    _fCandidateLeadAng3d = leadang3d;
    _fCandidateLeadStartX = leadstartx;
    _fCandidateLeadStartY = leadstarty;
    _fCandidateLeadStartZ = leadstartz;
    _fCandidateLeadEnergy = leadenergy;
    _fCandidateLeaddEdx0 = leaddedx0;
    _fCandidateLeaddEdx1 = leaddedx1;
    _fCandidateLeaddEdx2 = leaddedx2;
    _fCandidateLeaddEdx3 = leadbestdedx;
    _fCandidateLeadBestPlane = leadbestplane;
    _fCandidateLeadComposition = leadcomp;
    _fCandidateLeadPurity = leadpurity;
    _fCandidateLeadCompleteness = leadcompleteness;
    _fCandidateLeadEnergyBias = leadenergybias;
    _fCandidateLeadAngleBiasCosine = leadanglebiascosine;
    _fCandidateLeadAngleBiasDegrees = leadanglebiasdegrees;

    _fCandidateSubleadScore = subleadscore;
    _fCandidateSubleadLength = subleadlength;
    _fCandidateSubleadOpenAngle = subleadopenangle;
    _fCandidateSubleadDirX = subleaddirx;
    _fCandidateSubleadDirY = subleaddiry;
    _fCandidateSubleadDirZ = subleaddirz;
    _fCandidateSubleadCostheta = subleadcostheta;
    _fCandidateSubleadPhi = subleadphi;
    _fCandidateSubleadThetaXZ = subleadthetaxz;
    _fCandidateSubleadThetaYZ = subleadthetayz;
    _fCandidateSubleadDist3d = subleaddist3d;
    _fCandidateSubleadAng3d = subleadang3d;
    _fCandidateSubleadStartX = subleadstartx;
    _fCandidateSubleadStartY = subleadstarty;
    _fCandidateSubleadStartZ = subleadstartz;
    _fCandidateSubleadEnergy = subleadenergy;
    _fCandidateSubleaddEdx0 = subleaddedx0;
    _fCandidateSubleaddEdx1 = subleaddedx1;
    _fCandidateSubleaddEdx2 = subleaddedx2;
    _fCandidateSubleaddEdx3 = subleadbestdedx;
    _fCandidateSubleadBestPlane = subleadbestplane;
    _fCandidateSubleadComposition = subleadcomp;
    _fCandidateSubleadPurity = subleadpurity;
    _fCandidateSubleadCompleteness = subleadcompleteness;
    _fCandidateSubleadEnergyBias = subleadenergybias;
    _fCandidateSubleadAngleBiasCosine = subleadanglebiascosine;
    _fCandidateSubleadAngleBiasDegrees = subleadanglebiasdegrees;

    double angle12 = angleBetweenTwoShowers(leadcandidate,subleadcandidate);
    double acosangle12 = radToDeg(std::acos(angle12));
    double pi0mass = -99999.;
    double pi0momentum = -99999.;
    double pi0costheta = -99999.;
    double pi0phi = -99999.;
    double pi0energy = -99999.;
    
    pi0mass = pi0Mass(leadenergy,subleadenergy,angle12);
    pi0momentum = Altpi0Momentum(leadenergy,subleadenergy,angle12);
    pi0energy = std::sqrt(std::pow(pi0mass,2) + std::pow(pi0momentum,2));
    pi0costheta = pi0Angle(pi0momentum, leadenergy, subleadenergy, leadcandidate, subleadcandidate);
    pi0phi = pi0Phi(leadenergy, subleadenergy, leadcandidate, subleadcandidate);

    double pi0momentumbias = -999;
    double pi0anglebiascosine = -999;
    double pi0anglebiasdegrees = -999;

    if(fIsMC){
      if(_fNuInFV == 1 && std::abs(_fNuPDG) == 14 && _fNuCCNC == 0 && Npi0 == 1 && Nmuon == 1 && Npiplus == 0){
	pi0anglebiascosine = pi0AngleBias(_fPi0Px, _fPi0Py, _fPi0Pz, _fPi0P, pi0momentum, leadenergy, subleadenergy, leadcandidate, subleadcandidate);
	pi0anglebiasdegrees = cosineToDeg(pi0anglebiascosine);
	pi0momentumbias = pi0MomentumBias(_fPi0P, pi0momentum);
      }//signal
    }//fIsMC

    _fCandidatePi0Momentum = pi0momentum;
    _fCandidatePi0Energy = pi0energy;
    _fCandidatePi0Costheta = pi0costheta;
    _fCandidatePi0Phi = pi0phi;
    _fCandidatePi0Angle12 = acosangle12;
    _fCandidatePi0MomentumBias = pi0momentumbias;
    _fCandidatePi0AngleBiasCosine = pi0anglebiascosine;
    _fCandidatePi0AngleBiasDegrees = pi0anglebiasdegrees;

  }//ccpi0 selected events

  _eventtree->Fill();
 
}//analyze


//////////////////////////////////////////////////////////////////////
/////////////////////// ALL FUNCTIONS HERE ///////////////////////////
//////////////////////////////////////////////////////////////////////

double CCpi0Tree::getFlashChi2Weight(double x){

  double p0 = 1.99384917e-01;
  double p1 = -1.05022405e-10;
  double p2 = 6.34916308e-05;
  double p3 = -3.44705817e-03;
  double p4 = 7.32059307e-02;
  double p5 = -5.91696006e-01;
  double p6 = 2.14667463e+00;
  double p7 = -1.02545380e+00;
  double p8 = 3.65915734e-01;

  return exp(-p0*x)*(p1*pow(x, 6) + p2*pow(x,5) + p3*pow(x,4) + p4*pow(x,3) + p5*pow(x,2) + p6*x + p7) + p8;
  
}//getFlashChi2Weight

double CCpi0Tree::getNewFlashChi2Weight(double x){

  double p0 = 1.99926228e-01;
  double p1 = 7.88770729e-10;
  double p2 = 7.07517919e-05;
  double p3 = -3.78293911e-03;
  double p4 = 8.04431506e-02;
  double p5 = -6.42532837e-01;
  double p6 = 2.35485751e+00;
  double p7 = -1.01116606e+00;
  double p8 = 2.14473378e-01;

  return exp(-p0*x)*(p1*pow(x, 6) + p2*pow(x,5) + p3*pow(x,4) + p4*pow(x,3) + p5*pow(x,2) + p6*x + p7) + p8;

}//getNewFlashChi2Weight

double CCpi0Tree::getNewFlashChi2WeightRun2(double x){

  double p0 = 1.99926228e-01;
  double p1 = 7.88770729e-10;
  double p2 = 7.07517919e-05;
  double p3 = -3.78293911e-03;
  double p4 = 8.04431506e-02;
  double p5 = -6.42532837e-01;
  double p6 = 2.35485751e+00;
  double p7 = -1.01116606e+00;
  double p8 = 2.14473378e-01;

  return exp(-p0*x)*(p1*pow(x, 6) + p2*pow(x,5) + p3*pow(x,4) + p4*pow(x,3) + p5*pow(x,2) + p6*x + p7) + p8;

}//getNewFlashChi2WeightRun2

double CCpi0Tree::getNewFlashChi2WeightRun3(double x){

  double p0 = 1.99926228e-01;
  double p1 = 7.88770729e-10;
  double p2 = 7.07517919e-05;
  double p3 = -3.78293911e-03;
  double p4 = 8.04431506e-02;
  double p5 = -6.42532837e-01;
  double p6 = 2.35485751e+00;
  double p7 = -1.01116606e+00;
  double p8 = 2.14473378e-01;

  return exp(-p0*x)*(p1*pow(x, 6) + p2*pow(x,5) + p3*pow(x,4) + p4*pow(x,3) + p5*pow(x,2) + p6*x + p7) + p8;

}//getNewFlashChi2WeightRun3


int CCpi0Tree::bestPlane(std::vector<art::Ptr<recob::Hit>> hits){

  if(hits.size() == 0){std::cout<<"SHOWER HAS NO HITS!"<<std::endl;}

  int plane = -999;
  
  int nhitsU = 0;
  int nhitsV = 0;
  int nhitsY = 0;
  int nhitsMax = -999;
  
  for(auto const& ihit : hits){
    auto hitplane = ihit->View();
    if(hitplane == 0){nhitsU++;}
    if(hitplane == 1){nhitsV++;}
    if(hitplane == 2){nhitsY++;}
  }//shower hits

  nhitsMax = std::max(nhitsU,std::max(nhitsV,nhitsY));

  if(nhitsMax == nhitsU){plane = 0;}
  if(nhitsMax == nhitsV){plane = 1;}
  if(nhitsMax == nhitsY){plane = 2;}

  return plane;
  
}//bestPlane

bool CCpi0Tree::inFV(double x, double y, double z){
  // geo::GeometryCore const* fGeometry(lar::providerFrom<geo::Geometry>());
  //   double fDistToEdgeX             = fGeometry->DetHalfWidth()   - 20.;
  //   double fDistToEdgeY             = fGeometry->DetHalfHeight()  - 20.;
  //   double fDistToEdgeZ             = fGeometry->DetLength() / 2. - 10.;
  //   double distInX = x - fGeometry->DetHalfWidth();
  //   double distInY = y;
  //   double distInZ = z - 0.5 * fGeometry->DetLength();
    
  //   if (std::abs(distInX) < fDistToEdgeX && std::abs(distInY) < fDistToEdgeY && std::abs(distInZ) < fDistToEdgeZ)
  //     return true;

  //   return false;

   // if(x >= 5 && x <= 251){
    //   if(y >= -110 && y <= 110){
    // 	if((z >= 20 && z < 675) || (z > 775 && z <= 986)){
    // 	  return true;
    // 	}//z
    //   }//y
    // }//x

    if(x >= 10 && x <= 246){
      if(y >= -140 && y <= 140){
	if(z >= 10 && z <= 986.5){
	  return true;
	}//z
      }//y
    }//x
  
  return false;
    
}//inFV 

double CCpi0Tree::getPhi(double px, double py, double pz){ //from M. Del Tutto's UBXSec_module.cc

  TVector3 dir(px,py,pz);
  
  // We are in the plane Z = 0 
  dir.SetZ(0);
  TVector3 phi_versor (1, 0, 0);  
  
  double phi = phi_versor.Angle(dir);
  
  // Just convention
  if (dir.Y() < 0)
    phi = -phi;
  
  return phi;
  
}//getPhi


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// GET TRUTH INFORMATION //////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

double CCpi0Tree::getPurity(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, int Gamma1_id, int Gamma2_id, art::InputTag hitparticleassns_tag, int plane){

  art::ServiceHandle<cheat::ParticleInventoryService> particleinventory;
  auto const& allhits_handle = e.getValidHandle<std::vector<recob::Hit>>(allhits_tag);

  double purity = -99999;

  int shower_mcparticleid = -999; //mc particle id that contributes most energy to the shower
  float allmc_shower = -999.;
  float gamma1_shower = -999.;
  float gamma2_shower = -999.;
 
  int mcparticle_id = -999; //mcparticle that contributes most energy to shower
  float max_e = -999.; //max true energy deposition in the shower
  
  float mconly_shower = 0.; 
  float g1_shower = 0.; //energy deposited by gamma1 in the shower
  float g2_shower = 0.; //energy deposited by gamma2 in the shower
  
  std::vector<art::Ptr<recob::Hit>> overlayHits;
    
  ////////////// SHOWER HITS ///////////////////////////
  std::map<int,double> trkID_E; //map of track ID's and their deposited energies
  art::FindMany<simb::MCParticle,anab::BackTrackerHitMatchingData> particles_per_hit(allhits_handle,e,hitparticleassns_tag); //mc particles associated with all hits
  std::vector<simb::MCParticle const*> particle_vec; //vector of mc particles 
  std::vector<anab::BackTrackerHitMatchingData const*> match_vec; //vector of associations
  
  for(size_t i = 0; i < shower_hits.size(); i++){
    art::Ptr<recob::Hit> hit = shower_hits[i];
    auto hitplane = hit->View();
    if(hitplane != plane) continue;

    particle_vec.clear(); match_vec.clear();
    particles_per_hit.get(hit.key(),particle_vec,match_vec); //mc particles matched to each shower hit

    if(particle_vec.size() == 0){
      overlayHits.push_back(hit);
    }

    //ALL MCPARTICLES MATCHED TO CURRENT SHOWER HIT
    for(size_t i_p=0; i_p < particle_vec.size(); ++i_p){

      trkID_E[ particle_vec[i_p]->TrackId() ] += match_vec[i_p]->energy; //store energy per track id for all shower-matched mc particles
     
      //Particle with max energy contribution to hit
      if( trkID_E[particle_vec[i_p]->TrackId()] > max_e ){ 
	max_e = trkID_E[ particle_vec[i_p]->TrackId() ];
	mcparticle_id = particle_vec[i_p]->TrackId();
      }//max energy particle
      
    }//mcparticles per hit
    
  }//shower hit loop

  ////////// ALL HITS IN THE EVENT /////////////////////
  std::map<int,double> trkID_Eall; //map of track ID's and their deposited energies
  art::FindMany<simb::MCParticle,anab::BackTrackerHitMatchingData> particles_per_hitall(allhits_handle,e,hitparticleassns_tag); //mc particles associated with all hits
  std::vector<simb::MCParticle const*> particle_vecall; //vector of mc particles 
  std::vector<anab::BackTrackerHitMatchingData const*> match_vecall; //vector of associations
  
  for(size_t i = 0; i < all_hits.size(); i++){
    art::Ptr<recob::Hit> hit = all_hits[i];
    auto hitplane = hit->View();
    if(hitplane != plane) continue;
 
    particle_vecall.clear(); match_vecall.clear();
    particles_per_hitall.get(hit.key(),particle_vecall,match_vecall); //mc particles matched to each event hit

    //ALL MCPARTICLES MATCHED TO CURRENT EVENT HIT
    for(size_t i_p=0; i_p < particle_vecall.size(); ++i_p){

      trkID_Eall[ particle_vecall[i_p]->TrackId() ] += match_vecall[i_p]->energy; //store energy per track id for all matched mc particles
    
    }//mcparticles per hit

  }//all hit loop

  /////////////// SHOWER PARTICLE MAP //////////
  for(std::map<int,double>::iterator it = trkID_E.begin(); it!=trkID_E.end(); ++it){

    mconly_shower += it->second;
    
    //Check how much energy gamma1 deposited in the shower
    for(auto const& mcpart : Gamma1_descendents){
      if(mcpart->TrackId() == it->first){
	g1_shower += it->second;
      }
    }//g1

    //Check how much energy gamma2 deposited in the shower
    for(auto const& mcpart : Gamma2_descendents){
      if(mcpart->TrackId() == it->first){
	g2_shower += it->second;
      }
    }//g2
    
  }//trkide

  float overlay_shower = showerEnergy(2,overlayHits);

  allmc_shower = overlay_shower + mconly_shower;
  gamma1_shower = g1_shower;
  gamma2_shower = g2_shower;
  shower_mcparticleid = mcparticle_id;

  int momid = -999;
  for(auto const& mcpart : all_mcparticles){
    if(shower_mcparticleid == mcpart->TrackId()){
      momid = mcpart->Mother();
    }
  }//mcparticle loop

  //matches to gamma1
  if(momid == Gamma1_id){
    if(allmc_shower != 0.){purity = gamma1_shower/allmc_shower;}
  }//g1

  //matches to gamma2
  if(momid == Gamma2_id){
    if(allmc_shower != 0.){purity = gamma2_shower/allmc_shower;}
  }//g2

  return purity;
  
}//getPurity

double CCpi0Tree::getComplete(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, int Gamma1_id, int Gamma2_id, art::InputTag hitparticleassns_tag, int plane){

  art::ServiceHandle<cheat::ParticleInventoryService> particleinventory;
  auto const& allhits_handle = e.getValidHandle<std::vector<recob::Hit>>(allhits_tag);

  double complete = -99999;

  int shower_mcparticleid = -999; //mc particle id that contributes most energy to the shower
  float gamma1_shower = -999.;
  float gamma2_shower = -999.;
  float gamma1_event = -999.;
  float gamma2_event = -999.;
  
  int mcparticle_id = -999; //mcparticle that contributes most energy to shower
  float max_e = -999.; //max true energy deposition in the shower
  
  float g1_shower = 0.; //energy deposited by gamma1 in the shower
  float g2_shower = 0.; //energy deposited by gamma2 in the shower
  float g1_event = 0.; //energy deposited by gamma1 in the event
  float g2_event = 0.; //energy deposited by gamma2 in the event

  std::vector<art::Ptr<recob::Hit>> overlayHits;
    
  ////////////// SHOWER HITS ///////////////////////////
  std::map<int,double> trkID_E; //map of track ID's and their deposited energies
  art::FindMany<simb::MCParticle,anab::BackTrackerHitMatchingData> particles_per_hit(allhits_handle,e,hitparticleassns_tag); //mc particles associated with all hits
  std::vector<simb::MCParticle const*> particle_vec; //vector of mc particles 
  std::vector<anab::BackTrackerHitMatchingData const*> match_vec; //vector of associations
  
  for(size_t i = 0; i < shower_hits.size(); i++){
    art::Ptr<recob::Hit> hit = shower_hits[i];
    auto hitplane = hit->View();
    if(hitplane != plane) continue;

    particle_vec.clear(); match_vec.clear();
    particles_per_hit.get(hit.key(),particle_vec,match_vec); //mc particles matched to each shower hit

    //ALL MCPARTICLES MATCHED TO CURRENT SHOWER HIT
    for(size_t i_p=0; i_p < particle_vec.size(); ++i_p){

      trkID_E[ particle_vec[i_p]->TrackId() ] += match_vec[i_p]->energy; //store energy per track id for all shower-matched mc particles
     
      //Particle with max energy contribution to hit
      if( trkID_E[particle_vec[i_p]->TrackId()] > max_e ){ 
	max_e = trkID_E[ particle_vec[i_p]->TrackId() ];
	mcparticle_id = particle_vec[i_p]->TrackId();
      }//max energy particle
      
    }//mcparticles per hit
    
  }//shower hit loop

  ////////// ALL HITS IN THE EVENT /////////////////////
  std::map<int,double> trkID_Eall; //map of track ID's and their deposited energies
  art::FindMany<simb::MCParticle,anab::BackTrackerHitMatchingData> particles_per_hitall(allhits_handle,e,hitparticleassns_tag); //mc particles associated with all hits
  std::vector<simb::MCParticle const*> particle_vecall; //vector of mc particles 
  std::vector<anab::BackTrackerHitMatchingData const*> match_vecall; //vector of associations
  
  for(size_t i = 0; i < all_hits.size(); i++){
    art::Ptr<recob::Hit> hit = all_hits[i];
    auto hitplane = hit->View();
    if(hitplane != plane) continue;
 
    particle_vecall.clear(); match_vecall.clear();
    particles_per_hitall.get(hit.key(),particle_vecall,match_vecall); //mc particles matched to each event hit

    //ALL MCPARTICLES MATCHED TO CURRENT EVENT HIT
    for(size_t i_p=0; i_p < particle_vecall.size(); ++i_p){

      trkID_Eall[ particle_vecall[i_p]->TrackId() ] += match_vecall[i_p]->energy; //store energy per track id for all matched mc particles
    
    }//mcparticles per hit

  }//all hit loop

  ////////// GET CONTRIBUTIONS //////////////////////
  
  /////////////// SHOWER PARTICLE MAP //////////
  for(std::map<int,double>::iterator it = trkID_E.begin(); it!=trkID_E.end(); ++it){

    //Check how much energy gamma1 deposited in the shower
    for(auto const& mcpart : Gamma1_descendents){
      if(mcpart->TrackId() == it->first){
	g1_shower += it->second;
      }
    }//g1

    //Check how much energy gamma2 deposited in the shower
    for(auto const& mcpart : Gamma2_descendents){
      if(mcpart->TrackId() == it->first){
	g2_shower += it->second;
      }
    }//g2
    
  }//trkide

   /////////////// ALL PARTICLE MAP //////////
  for(std::map<int,double>::iterator it = trkID_Eall.begin(); it!=trkID_Eall.end(); ++it){

    //Check how much energy gamma1 deposited in the shower
    for(auto const& mcpart : Gamma1_descendents){
      if(mcpart->TrackId() == it->first){
	g1_event += it->second;
      }
    }//g1

    //Check how much energy gamma2 deposited in the shower
    for(auto const& mcpart : Gamma2_descendents){
      if(mcpart->TrackId() == it->first){
	g2_event += it->second;
      }
    }//g2
    
  }//trkide

  gamma1_shower = g1_shower;
  gamma2_shower = g2_shower;
  gamma1_event = g1_event;
  gamma2_event = g2_event;
  shower_mcparticleid = mcparticle_id;

  int momid = -999;
  for(auto const& mcpart : all_mcparticles){
    if(shower_mcparticleid == mcpart->TrackId()){
      momid = mcpart->Mother();
    }
  }//mcparticle loop

  //matches to gamma1
  if(momid == Gamma1_id){
    if(gamma1_event != 0.){complete = gamma1_shower/gamma1_event;}
  }//g1

  //matches to gamma2
  if(momid == Gamma2_id){
    if(gamma2_event != 0.){complete = gamma2_shower/gamma2_event;}
  }//g2

  return complete;
  
}//getComplete

double CCpi0Tree::getShowerBias(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, float Gamma1_E, float Gamma2_E, float energy, art::InputTag hitparticleassns_tag, int plane){

  art::ServiceHandle<cheat::ParticleInventoryService> particleinventory;
  auto const& allhits_handle = e.getValidHandle<std::vector<recob::Hit>>(allhits_tag);

  double energyres = -99999;

  int shower_mcparticleid = -999; //mc particle id that contributes most energy to the shower
  int mcparticle_id = -999; //mcparticle that contributes most energy to shower
  float max_e = -999.; //max true energy deposition in the shower
  
  ////////////// SHOWER HITS ///////////////////////////
  std::map<int,double> trkID_E; //map of track ID's and their deposited energies
  art::FindMany<simb::MCParticle,anab::BackTrackerHitMatchingData> particles_per_hit(allhits_handle,e,hitparticleassns_tag); //mc particles associated with all hits
  std::vector<simb::MCParticle const*> particle_vec; //vector of mc particles 
  std::vector<anab::BackTrackerHitMatchingData const*> match_vec; //vector of associations
  
  for(size_t i = 0; i < shower_hits.size(); i++){
    art::Ptr<recob::Hit> hit = shower_hits[i];
    auto hitplane = hit->View();
    if(hitplane != plane) continue;

    particle_vec.clear(); match_vec.clear();
    particles_per_hit.get(hit.key(),particle_vec,match_vec); //mc particles matched to each shower hit

    //ALL MCPARTICLES MATCHED TO CURRENT SHOWER HIT
    for(size_t i_p=0; i_p < particle_vec.size(); ++i_p){

      trkID_E[ particle_vec[i_p]->TrackId() ] += match_vec[i_p]->energy; //store energy per track id for all shower-matched mc particles
     
      //Particle with max energy contribution to hit
      if( trkID_E[particle_vec[i_p]->TrackId()] > max_e ){ 
	max_e = trkID_E[ particle_vec[i_p]->TrackId() ];
	mcparticle_id = particle_vec[i_p]->TrackId();
      }//max energy particle
      
    }//mcparticles per hit
    
  }//shower hit loop

  shower_mcparticleid = mcparticle_id;

  int momid = -999;
  for(auto const& mcpart : all_mcparticles){
    if(shower_mcparticleid == mcpart->TrackId()){
      momid = mcpart->Mother();
    }
  }//mcparticle loop

  //matches to gamma1
  if(momid == Gamma1_id){
    if(Gamma1_E != 0.){energyres = (Gamma1_E - energy)/Gamma1_E;}
  }//g1

  //matches to gamma2
  if(momid == Gamma2_id){
    if(Gamma2_E != 0.){energyres = (Gamma2_E - energy)/Gamma2_E;}
  }//g2

  return energyres;
  
}//getShowerBias

double CCpi0Tree::getTrueTrackComposition(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> track_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, art::InputTag hitparticleassns_tag, int plane){
  
  int truecomp = -99999; //1 = muon, 2 = proton, 3 = charged pion, 4 = photon, 5 = other em, 6 = overlay, 7 = other

  int mcparticleid = -999;
  float mcenergy = -999.;
  float overlayenergy = -999.;
  int pdgcode = -999;
  int mompdgcode = -999;
  int momid = -999;
 
  if(fIsMC){

    getTrueParticle(e, allhits_tag, all_hits, track_hits, hitparticleassns_tag, 2, mcparticleid, mcenergy);
    getOverlayEnergy(e, allhits_tag, all_hits, track_hits, hitparticleassns_tag, 2, overlayenergy);
	
    for(auto const& mcpart : all_mcparticles){
      if(mcparticleid == mcpart->TrackId()){
	momid = mcpart->Mother();
	pdgcode = mcpart->PdgCode();
	for(auto const& mcpart2 : all_mcparticles){
	  if(mcpart2->TrackId() == momid){
	    mompdgcode = mcpart2->PdgCode();
	  }
	}
      }
    }//mcparticle loop

    //mostly overlay
    if(overlayenergy > mcenergy){
      truecomp = 6;
    }//overlay
	
    if(overlayenergy <= mcenergy){

      if(std::abs(pdgcode) == 13){
	truecomp = 1;
      }

      if(std::abs(pdgcode) == 2212){
	truecomp = 2;
      }

      if(std::abs(pdgcode) == 211){
	truecomp = 3;
      }
	  
      if(std::abs(mompdgcode) == 22){
	truecomp = 4;
      }
	  
      if(std::abs(pdgcode) == 11){
	truecomp = 5;
      }
	  
      if(std::abs(pdgcode) != 13 && std::abs(pdgcode) != 11 && std::abs(pdgcode) != 2212 && std::abs(pdgcode) != 211 && std::abs(pdgcode) != 22){
	truecomp = 7;
      }
	  
    }//not overlay


  }//fIsMC

  return truecomp;

}//getTrueTrackComposition

double CCpi0Tree::getTrueComposition(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, art::InputTag hitparticleassns_tag, int plane){
  
  int truecomp = -99999; //1 = gamma1, 2 = gamma2, 3 = descendent, 4 = muon, 5 = proton, 6 = pion, 7 = other em, 8 = overlay, 9 = the rest

  int mcparticleid = -999;
  float mcenergy = -999.;
  float overlayenergy = -999.;
  int pdgcode = -999;
  int momid = -999;
  bool matchGamma1 = false;
  bool matchGamma2 = false;
  bool descendentGamma1 = false;
  bool descendentGamma2 = false;
  
  if(fIsMC){

    getTrueParticle(e, allhits_tag, all_hits, shower_hits, hitparticleassns_tag, 2, mcparticleid, mcenergy);
    getOverlayEnergy(e, allhits_tag, all_hits, shower_hits, hitparticleassns_tag, 2, overlayenergy);
	
    for(auto const& mcpart : all_mcparticles){
      if(mcparticleid == mcpart->TrackId()){
	momid = mcpart->Mother();
	pdgcode = mcpart->PdgCode();
      }
    }//mcparticle loop

    if(momid == Gamma1_id){
      matchGamma1 = true;
    }
    if(momid == Gamma2_id){
      matchGamma2 = true;
    }

    //mostly overlay
    if(overlayenergy > mcenergy){
      truecomp = 8;
    }//overlay
	
    if(overlayenergy <= mcenergy){
	  
      if(matchGamma1 == true){
	truecomp = 1;
      }//gamma1
	  
      if(matchGamma2 == true){
	truecomp = 2;
      }//gamma2

      if(matchGamma1 == false && matchGamma2 == false){
	for(auto const & mcpart : Gamma1_descendents){
	  if(mcparticleid == mcpart->TrackId()){descendentGamma1 = true;}
	}
	for(auto const & mcpart : Gamma2_descendents){
	  if(mcparticleid == mcpart->TrackId()){descendentGamma2 = true;}
	}
      }

      if(descendentGamma1 == true || descendentGamma2 == true){
	truecomp = 3;
      }
	  
      if(std::abs(pdgcode) == 13){
	truecomp = 4;
      }
	  
      if(std::abs(pdgcode) == 2212){
	truecomp = 5;
      }
	  
      if(std::abs(pdgcode) == 211){
	truecomp = 6;
      }
	  
      if((std::abs(pdgcode) == 11) && matchGamma1 == false && matchGamma2 == false && descendentGamma1 == false && descendentGamma2 == false){
	truecomp = 7;
      }

      if(matchGamma1 == false && matchGamma2 == false && descendentGamma1 == false && descendentGamma2 == false && std::abs(pdgcode) != 13 && std::abs(pdgcode) != 2212 && std::abs(pdgcode) != 211 && std::abs(pdgcode) != 11){
	truecomp = 9;
      }
	  
    }//not overlay


  }//fIsMC

  return truecomp;

}//getTrueComposition

void CCpi0Tree::getKids(std::vector<art::Ptr<simb::MCParticle>> all_mcpart_vector, int mcpart_id, std::vector<art::Ptr<simb::MCParticle>>& mcpart_kids){

  std::vector< std::vector< TVector2 > > particleV; //vector of vector of (particle id, number of daughter) pairs
  std::vector< TVector2 > mapV; //pairs of (particle id, number of daughter) at each stage
  std::map<int, art::Ptr<simb::MCParticle> > mcpart_id_map; //map from mcparticle to mcparticle id
  
  for(auto const& mcpart: all_mcpart_vector){ 
    mcpart_id_map[mcpart->TrackId()] = mcpart;

    //Step n = 0, get our particle's immediate kids
    if(mcpart->TrackId() == mcpart_id){
      for(int i = 0; i < mcpart->NumberDaughters(); i++){
	for(auto const& mcpart2: all_mcpart_vector){
	  int id = mcpart2->TrackId();
	  int nd = mcpart2->NumberDaughters();
	  if(mcpart2->TrackId() == mcpart->Daughter(i)){
	    mcpart_kids.push_back(mcpart2);
	    mapV.push_back( TVector2(id,nd) );
	  }
	}
      }
    }//our particle
  }//mcparticle loop
  particleV.push_back(mapV);

  //Now get the rest of the descendents
  int n = 1;
  while(n){
    
    if(particleV.at(n-1).size() == 0) break;
    mapV.clear();
    
    for(size_t i = 0; i < particleV.at(n-1).size(); i++){ //loop over (particle id, number of daughter) pairs at previous stage
      int parent_id = particleV.at(n-1).at(i).X(); //mc particle id
      int parent_nd = particleV.at(n-1).at(i).Y(); //number of daughters
      auto const parent_mcpart = mcpart_id_map[parent_id]; 
      
      for(int j = 0; j < parent_nd; j++){ //daughters 
	
	for(auto const & mcpart : all_mcpart_vector){
	  int id = mcpart->TrackId();
	  int nd = mcpart->NumberDaughters();
	  
	  if(id == parent_mcpart->Daughter(j)){ 
	    mapV.push_back( TVector2(id,nd) );
	    mcpart_kids.push_back(mcpart);
	    
	  }//daughter mcpart
	  
	}//mcpart loop
	
      }//ndaughters
      
    }//particle vector
    
    particleV.push_back(mapV);
    
    n++;
	  
  }//while
  
}//getKids

void CCpi0Tree::getOverlayEnergy(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane, float& overlay_energy){

  art::ServiceHandle<cheat::ParticleInventoryService> particleinventory;
  auto const& allhits_handle = e.getValidHandle<std::vector<recob::Hit>>(allhits_tag);

  overlay_energy = 0;
   
  std::map<int,double> trkID_E; //map of track ID's and their deposited energies
  art::FindMany<simb::MCParticle,anab::BackTrackerHitMatchingData> particles_per_hit(allhits_handle,e,hitparticleassns_tag); //mc particles associated with all hits
  std::vector<simb::MCParticle const*> particle_vec; //vector of mc particles 
  std::vector<anab::BackTrackerHitMatchingData const*> match_vec; //vector of associations

  std::vector<art::Ptr<recob::Hit>> overlay_hits;

  //Shower hits loop
  for(size_t i = 0; i < shower_hits.size(); i++){
    art::Ptr<recob::Hit> hit = shower_hits[i];
    auto hitplane = hit->View();
    if(hitplane != plane) continue;

    particle_vec.clear(); match_vec.clear();
    particles_per_hit.get(hit.key(),particle_vec,match_vec); //mc particles matched to each shower hit

    if(particle_vec.size() == 0){
      std::cout<<"FOUND OVERLAY HIT IN SHOWER!"<<std::endl;
      overlay_hits.push_back(hit);
    }

  }//shower hit loop

  overlay_energy = showerEnergy(plane,overlay_hits);

}//getOverlayEnergy

void CCpi0Tree::getTrueParticle(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane, int& shower_mcparticleid, float& shower_mcenergy){

  art::ServiceHandle<cheat::ParticleInventoryService> particleinventory;
  auto const& allhits_handle = e.getValidHandle<std::vector<recob::Hit>>(allhits_tag);

  shower_mcparticleid = -999; //mc particle id that contributes most energy to the shower
  shower_mcenergy = -999;
  
  int mcparticle_id = -999; //mcparticle that contributes most energy to shower
  float max_e = -999.; //max true energy deposition in the shower
  
  ////////////// SHOWER HITS ///////////////////////////
  std::map<int,double> trkID_E; //map of track ID's and their deposited energies
  art::FindMany<simb::MCParticle,anab::BackTrackerHitMatchingData> particles_per_hit(allhits_handle,e,hitparticleassns_tag); //mc particles associated with all hits
  std::vector<simb::MCParticle const*> particle_vec; //vector of mc particles 
  std::vector<anab::BackTrackerHitMatchingData const*> match_vec; //vector of associations
  
  for(size_t i = 0; i < shower_hits.size(); i++){
    art::Ptr<recob::Hit> hit = shower_hits[i];
    auto hitplane = hit->View();
    if(hitplane != plane) continue;

    particle_vec.clear(); match_vec.clear();
    particles_per_hit.get(hit.key(),particle_vec,match_vec); //mc particles matched to each shower hit

    //ALL MCPARTICLES MATCHED TO CURRENT SHOWER HIT
    for(size_t i_p=0; i_p < particle_vec.size(); ++i_p){

      trkID_E[ particle_vec[i_p]->TrackId() ] += match_vec[i_p]->energy; //store energy per track id for all shower-matched mc particles
     
      //Particle with max energy contribution to hit
      if( trkID_E[particle_vec[i_p]->TrackId()] > max_e ){ 
	max_e = trkID_E[ particle_vec[i_p]->TrackId() ];
	mcparticle_id = particle_vec[i_p]->TrackId();
      }//max energy particle
      
    }//mcparticles per hit

  }//shower hit loop

  shower_mcparticleid = mcparticle_id;
  shower_mcenergy = max_e;

}//getTrueParticle

int CCpi0Tree::getTrueParticleID(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane){

  int shower_mcparticleid = -999; //mc particle id that contributes most energy to the shower

  art::ServiceHandle<cheat::ParticleInventoryService> particleinventory;
  auto const& allhits_handle = e.getValidHandle<std::vector<recob::Hit>>(allhits_tag);
  
  int mcparticle_id = -999; //mcparticle that contributes most energy to shower
  float max_e = -999.; //max true energy deposition in the shower
  
  ////////////// SHOWER HITS ///////////////////////////
  std::map<int,double> trkID_E; //map of track ID's and their deposited energies
  art::FindMany<simb::MCParticle,anab::BackTrackerHitMatchingData> particles_per_hit(allhits_handle,e,hitparticleassns_tag); //mc particles associated with all hits
  std::vector<simb::MCParticle const*> particle_vec; //vector of mc particles 
  std::vector<anab::BackTrackerHitMatchingData const*> match_vec; //vector of associations
  
  for(size_t i = 0; i < shower_hits.size(); i++){
    art::Ptr<recob::Hit> hit = shower_hits[i];
    auto hitplane = hit->View();
    if(hitplane != plane) continue;

    particle_vec.clear(); match_vec.clear();
    particles_per_hit.get(hit.key(),particle_vec,match_vec); //mc particles matched to each shower hit

    //ALL MCPARTICLES MATCHED TO CURRENT SHOWER HIT
    for(size_t i_p=0; i_p < particle_vec.size(); ++i_p){

      trkID_E[ particle_vec[i_p]->TrackId() ] += match_vec[i_p]->energy; //store energy per track id for all shower-matched mc particles
     
      //Particle with max energy contribution to hit
      if( trkID_E[particle_vec[i_p]->TrackId()] > max_e ){ 
	max_e = trkID_E[ particle_vec[i_p]->TrackId() ];
	mcparticle_id = particle_vec[i_p]->TrackId();
      }//max energy particle
      
    }//mcparticles per hit

  }//shower hit loop

  shower_mcparticleid = mcparticle_id;

  return shower_mcparticleid;

}//getTrueParticleID
 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// CALORIMETRY ///////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float CCpi0Tree::showerEnergy(int plane, std::vector<art::Ptr<recob::Hit>> hits){

  float energy = 0.;

  //Calibration: converting charge to energy
  //Hit energy = hit integral [ADC] * gain [e-/ADC] * work function [MeV/e] * 1/recombination factor

 
  float work_function = 23.6e-6;
  float recombination_factor = 0.62;

  if(hits.size() == 0){std::cout<<"SHOWER HAS NO HITS!"<<std::endl;}
  
  for(auto const& ihit : hits){
    auto hitplane = ihit->View();
    if(hitplane != plane) continue; //get hits from current plane
    float current_hit_charge = ihit->Integral(); //ADC
    float current_hit_energy = -9999.;

    if(!fIsMC){current_hit_energy = current_hit_charge*data_gain[hitplane]*work_function*(1/recombination_factor);}
    if(fIsMC){current_hit_energy = current_hit_charge*overlay_gain[hitplane]*work_function*(1/recombination_factor);}
    energy += current_hit_energy;
  }//shower hits

  return energy;
  
}//showerEnergy

double CCpi0Tree::QtoEConversion(double Q){
  float work_function = 23.6e-6;
  float recombination_factor = 0.62;
  
  double E = Q*work_function*(1/recombination_factor);
  return E;
  
}//QtoEConversion

double CCpi0Tree::getAnglewrtWires(TVector3 shower_dir,int plane){
  
  TVector3 wire_dir = getWireVec(plane);
  double cos_theta =  getCoswrtWires(shower_dir, wire_dir);
  
  double theta = acos(cos_theta);
  // return abs(theta);
  return abs(3.14/2 - theta);
  
}//getAnglewrtWires

double CCpi0Tree::getMedian(std::vector<double> thisvector){
  //here the size corresponds to the max index
  int size = thisvector.size() - 1;
  //if no entries, return nonsense value
  if (size <= 0) return NAN;
  
  //find index of median location
  int ind;
  if (size%2 == 0) ind = size/2;
  else ind = size/2 + 1;
  //std::cout<<"the median index in vector with size "<<size+1<<" and  max index "<<size<<" is "<<ind<<std::endl;
  
  double median = thisvector[ind];
  //std::cout<<"returning median value "<< median<<std::endl;
  //return the value at median index
  return median;		
}//getMedian

double CCpi0Tree::getAmalgamateddEdx(double angle_wrt_plane0, double angle_wrt_plane1, double angle_wrt_plane2, double median_plane0, double median_plane1, double median_plane2, int plane0_nhits, int plane1_nhits, int plane2_nhits){
  
  //if the shower is within 10 degrees of the wires on plane 2, consider planes 1 and 0
  if(angle_wrt_plane2 < degToRad(10)){
    
    //if it's too close to the wires on either of the planes, then stick with plane 2
    if (angle_wrt_plane1> degToRad(20)|| angle_wrt_plane0>degToRad(20) ){
      
      //but if it's outside of the range on plane 1, choose that
      if(angle_wrt_plane1> angle_wrt_plane0){
	return median_plane1;
      } else{
	return median_plane0;
      }
    }
  }
  if (plane2_nhits< 2){
    if (plane1_nhits >=2 ){           
      return median_plane1;
    } else if (plane0_nhits >=2 ){
      return median_plane0;
    }
  }
  
  return median_plane2;
}//getAmalgamateddEdx

double CCpi0Tree::degToRad(double deg){
  return (deg*3.14)/180;
}//degToRad

double CCpi0Tree::radToDeg(double rad){
  return (rad*180)/3.14;
}//radToDeg

double CCpi0Tree::cosineToDeg(double cosine){

  double radians = -999;
  double degrees = -999;

  if(cosine >= -1 && cosine <= 1){
    radians = std::acos(cosine);
    degrees = radToDeg(radians);
  }

  return degrees;

}//cosineToDeg


double CCpi0Tree::GetQHit(art::Ptr<recob::Hit> thishitptr, int plane){

  float charge = -999;
  if(!fIsMC){charge = thishitptr->Integral() * data_gain[plane];}
  if(fIsMC){charge = thishitptr->Integral() * overlay_gain[plane];}
  
  return charge;
}//GetQHit

double CCpi0Tree::getPitch(TVector3 shower_dir, int plane){
  //get the wire direction for this plane - values are hardcoded which isn't great but the TPC geom object gave weird values
  TVector3 wire_dir = getWireVec(plane);

  //take dot product of shower and wire dir
  double cos = getCoswrtWires(shower_dir, wire_dir);
  
  //want only positive values so take abs, normalize by the lengths of the shower and wire
  cos = abs(cos)/(wire_dir.Mag() * shower_dir.Mag());	
  
  //If the cos is 0 shower is perpendicular and therefore get infinite distance 
  if (cos == 0){ return std::numeric_limits<double>::max(); }
  
  //output is always >= the wire spacing
  return m_wire_spacing/cos;
}//getPitch

TVector3 CCpi0Tree::getWireVec(int plane){
  TVector3 wire_dir;
  if (plane == 0){
    wire_dir = {0., -sqrt(3) / 2., 1 / 2.};
  } else if (plane == 1){
    wire_dir = {0., sqrt(3) / 2., 1 / 2.};
  } else if (plane == 2) {
    wire_dir = {0., 0., 1.};
  }
  return wire_dir;
  
}//getWireVec

double CCpi0Tree::getCoswrtWires(TVector3 shower_dir, TVector3 wire_dir){
  //take the dot product between the wire direction and the shower direction
  double cos = wire_dir.Dot(shower_dir);
  return cos;
}//getCoswrtWires

std::vector<std::vector<double>> CCpi0Tree::buildRectangle(std::vector<double> cluster_start, std::vector<double> cluster_axis, double width, double length){
  std::vector<std::vector<double>> corners;
  
  //get the axis perpedicular to the cluster axis
  double perp_axis[2] = {-cluster_axis[1], cluster_axis[0]};
  
  //create a vector for each corner of the rectangle on the plane
  //c1 = bottom left corner
  std::vector<double> c1 = {cluster_start[0] + perp_axis[0] * width / 2,  cluster_start[1] + perp_axis[1] * width / 2};
  //c2 = top left corner
  std::vector<double> c2 = {c1[0] + cluster_axis[0] * length, c1[1] + cluster_axis[1] * length};
  //c3 = bottom right corner
  std::vector<double> c3 = {cluster_start[0] - perp_axis[0] * width / 2, cluster_start[1] - perp_axis[1] * width / 2};
  //c4 = top right corner
  std::vector<double> c4 ={c3[0] + cluster_axis[0] * length, c3[1] + cluster_axis[1] * length}; 
  
  //save each of the vectors
  corners.push_back(c1);
  corners.push_back(c2);
  corners.push_back(c4);
  corners.push_back(c3);
  return corners;
}//buildRectangle

bool CCpi0Tree::isInsidev2(std::vector<double> thishit_pos, std::vector<std::vector<double >> rectangle, float trunklength){
  int n_vertices = (int)rectangle.size();
  //bool inside = false;
  int i, j = 0;
  double areas = 0;
  //for each pair of vertices
  for (i = 0, j = n_vertices-1; i < n_vertices; j = i++) {
    //calculate the area of a triangle with the point and two vertices
    double this_area = areaTriangle(rectangle[i][0], rectangle[i][1], rectangle[j][0], rectangle[j][1], thishit_pos[0], thishit_pos[1]);
    areas += this_area;
  }        
  //calc area of the rectangle
  double area_rectangle = m_width_dqdx_box*trunklength;
  
  //check the sum of areas match
  if (abs(areas - area_rectangle) <= 0.001 ){
    return true;
  }
  return false;
}//isInsidev2

double CCpi0Tree::areaTriangle(double x1, double y1, double x2, double y2, double x3, double y3){
  double num = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2);
  return abs(num)/2;
}//areaTriangle


void CCpi0Tree::getdEdx(art::Event const & e, art::InputTag calo_tag, art::InputTag shower_tag, art::InputTag pfp_tag, art::InputTag track_tag, art::InputTag trackfitter_tag, art::InputTag cluster_tag, art::Ptr<recob::Shower> shower, std::vector<art::Ptr<recob::PFParticle>> nuPFParticles, std::vector<art::Ptr<recob::Track>> TrackFitterVector, int trackID, float trunklength, float trunkwidth, double& dedx0, double& dedx1, double& dedx2, double& amalgdedx){

  auto const& trackfitter_handle = e.getValidHandle<std::vector<recob::Track>>(trackfitter_tag);
  auto const& track_handle = e.getValidHandle<std::vector<recob::Track>>(track_tag);
  auto const& shower_handle = e.getValidHandle<std::vector<recob::Shower>>(shower_tag);
  auto const& cluster_handle = e.getValidHandle<std::vector<recob::Cluster>>(cluster_tag);
  auto const& pfp_handle = e.getValidHandle<std::vector<recob::PFParticle>>(pfp_tag);
  
  art::FindManyP<anab::Calorimetry> TrackCaloAssoc(trackfitter_handle,e,calo_tag);
  art::FindManyP<recob::Shower> pfPartToShowerAssoc(pfp_handle,e,"pandora");
  art::FindManyP<recob::Cluster> pfPartToClusterAssoc(pfp_handle,e,"pandora");
  art::FindManyP<recob::Hit> fmhs(shower_handle,e,shower_tag);
  art::FindManyP<recob::Hit> fmhc(cluster_handle,e,cluster_tag);
  art::FindManyP<recob::Hit> fmht(track_handle,e,track_tag);

  std::cout<<trunklength<<trunkwidth<<std::endl;
  
  dedx0 = -999;
  dedx1 = -999;
  dedx2 = -999;
  amalgdedx = -999;
  
  float track_dedx0 = -99999.;
  float track_dedx1 = -99999.;
  float track_dedx2 = -99999.;

  //track fitter dedx
  bool matchedToTrackFitter = false;
  //int trackID = -9999;
  //trackID = nuShowerTrackMap[shower];
  std::cout<<trackID<<std::endl;
  for(auto const& track : TrackFitterVector){
    if(track->ID() != trackID) continue;
    matchedToTrackFitter = true;
    TrackFitdEdx(TrackCaloAssoc.at(track.key()), trunklength, track_dedx0, track_dedx1, track_dedx2);
  }//track fitter loop
  
  //shower dedx
  double amalgamated_dedx = -999.;
  std::vector<double> shower_dQdx_0;
  std::vector<double> shower_dQdx_1;
  std::vector<double> shower_dQdx_2;
  std::vector<double> shower_dEdx_0;
  std::vector<double> shower_dEdx_1;
  std::vector<double> shower_dEdx_2;
  double median_dedx_0 = -999.;
  double median_dedx_1 = -999.;    
  double median_dedx_2 = -999.;
  
  TVector3 shr_dir = shower->Direction();
  float angle_0 = getAnglewrtWires(shr_dir, 0);
  float angle_1 = getAnglewrtWires(shr_dir, 1);
  float angle_2 = getAnglewrtWires(shr_dir, 2);
  float dirz = shower->Direction().Z();
  float diru = std::cos(angle_0);
  float dirv =  std::cos(angle_1);
  float acosdirz = std::acos(dirz);
  
  std::cout<<"CHECK ANGLES!!! Theta wrt z = "<<acosdirz<<" wrt u = "<<angle_0<<" wrt v = "<<angle_1<<" cosine theta wrt z = "<<dirz<<" wrt u = "<<diru<<" wrt v = "<<dirv<<std::endl;
  
  //find matched clusters
  std::vector<art::Ptr<recob::Cluster> > matchedClusters;
  for(auto const& pfp : nuPFParticles){
    const auto associatedShowers = pfPartToShowerAssoc.at(pfp.key());
    const auto associatedClusters = pfPartToClusterAssoc.at(pfp.key());
    bool matched_to_shower = false;
    
    if (associatedShowers.size() > 0){
      for(size_t i = 0; i < associatedShowers.size(); i++){
  	auto const sh = associatedShowers[i];
  	if(sh == shower){
  	  matched_to_shower = true;
  	}//matched
      }//associated showers
    }//has associated showers
    
    if(matched_to_shower == true){
      if (associatedClusters.size() > 0){
  	for(size_t i = 0; i < associatedClusters.size(); i++){
  	  auto const cl = associatedClusters[i];
  	  matchedClusters.push_back(cl);
  	}//associated clusters
      }//has associated clusters
    }//matched
  }//nupfp
  
  //Clusters associated with current shower
  for(auto const& cluster : matchedClusters){
    std::vector<double> dQdx_0;
    std::vector<double> dQdx_1;
    std::vector<double> dQdx_2;
    
    if(cluster->View() == 0){dQdx_0 = CalcdQdxShower(shower, cluster, fmhc.at(cluster.key()), 0, trunklength);}
    if(cluster->View() == 1){dQdx_1 = CalcdQdxShower(shower, cluster, fmhc.at(cluster.key()), 1, trunklength);}
    if(cluster->View() == 2){dQdx_2 = CalcdQdxShower(shower, cluster, fmhc.at(cluster.key()), 2, trunklength);}
    
    //plane 0
    for(size_t i = 0; i < dQdx_0.size(); i++){
      double thisdQdx = dQdx_0.at(i);
      double thisdEdx = QtoEConversion(dQdx_0.at(i));
      shower_dQdx_0.push_back(thisdQdx);
      shower_dEdx_0.push_back(thisdEdx);
    }//0
    
    //plane 1
    for(size_t i = 0; i < dQdx_1.size(); i++){
      double thisdQdx = dQdx_1.at(i);
      double thisdEdx = QtoEConversion(dQdx_1.at(i));
      shower_dQdx_1.push_back(thisdQdx);
      shower_dEdx_1.push_back(thisdEdx);
    }//1
    
    //plane 2
    for(size_t i = 0; i < dQdx_2.size(); i++){
      double thisdQdx = dQdx_2.at(i);
      double thisdEdx = QtoEConversion(dQdx_2.at(i));
      shower_dQdx_2.push_back(thisdQdx);
      shower_dEdx_2.push_back(thisdEdx);
    }//2
    
  }//cluster loop
  
  //calculate output variables
  median_dedx_0 = getMedian(shower_dEdx_0);
  median_dedx_1 = getMedian(shower_dEdx_1);
  median_dedx_2 = getMedian(shower_dEdx_2);
  amalgamated_dedx = getAmalgamateddEdx(angle_0, angle_1, angle_2, median_dedx_0, median_dedx_1, median_dedx_2, shower_dEdx_0.size(), shower_dEdx_1.size(), shower_dEdx_2.size());

  if(matchedToTrackFitter == true){
    dedx0 = track_dedx0;
    dedx1 = track_dedx1;
    dedx2 = track_dedx2;
  }
  if(matchedToTrackFitter == false){
    dedx0 = median_dedx_0;
    dedx1 = median_dedx_1;
    dedx2 = median_dedx_2;
  }
  amalgdedx = amalgamated_dedx;
  
}//getdEdx

void CCpi0Tree::TrackFitdEdx(std::vector<art::Ptr<anab::Calorimetry>> trackcaloobjects, float trunklength, float &dedxU, float &dedxV, float &dedxY){

  dedxU = -1;
  dedxV = -1;
  dedxY = -1;

  float work_function = 23.6e-6;
  float recombination_factor = 0.62;

  for (const auto &tkcalo : trackcaloobjects){

    if (tkcalo->ResidualRange().size() == 0)
      continue;

    auto pl = tkcalo->PlaneID().Plane;
    
    std::vector<float> dedx4cm;
    
    for (size_t ic = 0; ic < tkcalo->ResidualRange().size(); ++ic){
      
      if ((tkcalo->ResidualRange().back() - tkcalo->ResidualRange()[ic]) < trunklength){
	float this_dqdx = tkcalo->dQdx()[ic];
	float this_dedx = -999;
	  if(!fIsMC){this_dedx = this_dqdx*data_gain[pl]*work_function*(1/recombination_factor);}
	if(fIsMC){this_dedx = this_dqdx*overlay_gain[pl]*work_function*(1/recombination_factor);}
        dedx4cm.push_back(this_dedx);
      }
    }
    
    float dedx4cm_med = -1.;
    if (dedx4cm.size() > 0)
      {
	std::sort(dedx4cm.begin(), dedx4cm.end());
	if (dedx4cm.size() % 2 == 1)
	  dedx4cm_med = dedx4cm[dedx4cm.size() / 2];
	else
	  dedx4cm_med = 0.5 * (dedx4cm[dedx4cm.size() / 2] + dedx4cm[dedx4cm.size() / 2 - 1]);
      }

    
    if (pl == 0)
      {
	dedxU = dedx4cm_med;
      }
    if (pl == 1)
      {
	dedxV = dedx4cm_med;
      }
    if (pl == 2)
      {
	dedxY = dedx4cm_med;
      }

  } // for all calorimetry objects associated to the track

  return;
}//TrackFitdEdx


std::vector<double> CCpi0Tree::CalcdQdxShower(const art::Ptr<recob::Shower>& shower, const art::Ptr<recob::Cluster>& thiscluster, std::vector<art::Ptr<recob::Hit>> hits,  int plane, float trunklength){

  std::vector<double> dqdx;
  
  //get the 3D shower direction
  //note: in previous versions of the code there was a check to fix cases where the shower direction was inverted - this hasn't been implemented
  TVector3 shower_dir(shower->Direction().X(), shower->Direction().Y(),shower->Direction().Z());
  
  //calculate the pitch for this plane
  double pitch = getPitch(shower_dir, plane);	
  
  //keep only clusters on the plane
  if(thiscluster->View() == plane) {
  
    //calculate the cluster direction
    std::vector<double> cluster_axis = {cos(thiscluster->StartAngle()), sin(thiscluster->StartAngle())};		
    
    //get the cluster start and end in CM
    std::cout<<"for plane/tpc/cryo:"<<plane<<"/"<<m_TPC<<"/"<<m_Cryostat<<", fXTicksOffset: "<<theDetector->GetXTicksOffset(plane, m_TPC, m_Cryostat)<<" fXTicksCoefficient: "<<theDetector->GetXTicksCoefficient(m_TPC, m_Cryostat)<<std::endl;
    
    //convert the cluster start and end positions to time and wire coordinates
    std::vector<double> cluster_start = {thiscluster->StartWire() * m_wire_spacing,(thiscluster->StartTick() - theDetector->TriggerOffset())* _time2cm};
    std::vector<double> cluster_end = {thiscluster->EndWire() * m_wire_spacing,(thiscluster->EndTick() - theDetector->TriggerOffset())* _time2cm };
    
    //check that the cluster has non-zero length
    double length = sqrt(pow(cluster_end[0] - cluster_start[0], 2) + pow(cluster_end[1] - cluster_start[1], 2));
    if (length <= 0){ 
      std::cout<<"skipping cluster on plane "<<plane<<", length = "<<length<<std::endl;
      //continue;
    }

    if(length > 0){
    
      //draw a rectangle around the cluster axis 
      std::vector<std::vector<double>> rectangle = buildRectangle(cluster_start, cluster_axis, m_width_dqdx_box, trunklength);	

      //for each hit in the cluster
      for (art::Ptr<recob::Hit> &thishit: hits){	
	//get the hit position in cm from the wire and time
	std::vector<double> thishit_pos = {thishit->WireID().Wire * m_wire_spacing, (thishit->PeakTime() - theDetector->TriggerOffset())* _time2cm};
	
	//check if inside the box
	bool v2 = isInsidev2(thishit_pos, rectangle, trunklength);
	if (v2){
	  double q = GetQHit(thishit, plane); 
	  double this_dqdx = q/pitch; 
	  dqdx.push_back(this_dqdx);
	}//if hit falls inside the box
	
      }//for each hit inthe cluster
    }//cluster has length
  }//cluster on plane
  return dqdx;
  
}//CalcdQdxShower

float CCpi0Tree::XOffset(float t){
  auto const &detProperties = lar::providerFrom<detinfo::DetectorPropertiesService>();
  auto const &detClocks = lar::providerFrom<detinfo::DetectorClocksService>();
  double g4Ticks = detClocks->TPCG4Time2Tick(t) + detProperties->GetXTicksOffset(0, 0, 0) - detProperties->TriggerOffset();
  float xoffset = detProperties->ConvertTicksToX(g4Ticks, 0, 0, 0);
  xoffset += 0.6;
  return xoffset;
}//XOffset


///////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// PI0 FUNCTIONS ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

double CCpi0Tree::conversionDistance(art::Ptr<recob::Shower> shower, float vx, float vy, float vz){

  float dist3d = -99999.;

  auto showerOffset = SCE->GetCalPosOffsets(geo::Point_t(shower->ShowerStart().X(), shower->ShowerStart().Y(), shower->ShowerStart().Z()));
  double startx = shower->ShowerStart().X() - showerOffset.X();
  double starty = shower->ShowerStart().Y() + showerOffset.Y();
  double startz = shower->ShowerStart().Z() + showerOffset.Z();

  dist3d = std::sqrt(std::pow(vx - startx,2) + std::pow(vy - starty,2) + std::pow(vz - startz,2));

  return dist3d;

}//conversionDistance


double CCpi0Tree::radialAngle(art::Ptr<recob::Shower> shower, float vx, float vy, float vz){

  float ang3d = -9999.;
  
  auto showerOffset = SCE->GetCalPosOffsets(geo::Point_t(shower->ShowerStart().X(), shower->ShowerStart().Y(), shower->ShowerStart().Z()));
  double startx = shower->ShowerStart().X() - showerOffset.X();
  double starty = shower->ShowerStart().Y() + showerOffset.Y();
  double startz = shower->ShowerStart().Z() + showerOffset.Z();
  double dirx = shower->Direction().X();
  double diry = shower->Direction().Y();
  double dirz = shower->Direction().Z();
  float dist3d = std::sqrt(std::pow(vx - startx,2) + std::pow(vy - starty,2) + std::pow(vz - startz,2));

  ang3d = (((startx - vx)*dirx) + ((starty - vy)*diry) + ((startz - vz)*dirz))/dist3d;

  std::cout<<"CHECK3: SHOWER ANGLE! "<<ang3d<<std::endl;

  return ang3d;
}//radialAngle

double CCpi0Tree::trackRadialAngle(art::Ptr<recob::Track> track, float vx, float vy, float vz){

  float ang3d = -9999.;

  auto trackVertexOffset = SCE->GetCalPosOffsets(geo::Point_t(track->Vertex().X(), track->Vertex().Y(), track->Vertex().Z()));
  auto trackVertexEndOffset = SCE->GetCalPosOffsets(geo::Point_t(track->End().X(), track->End().Y(), track->End().Z()));
  
  double trackVertexX = track->Vertex().X() - trackVertexOffset.X();
  double trackVertexY = track->Vertex().Y() + trackVertexOffset.Y();
  double trackVertexZ = track->Vertex().Z() + trackVertexOffset.Z();
  double trackVertexEndX = track->End().X() - trackVertexEndOffset.X();
  double trackVertexEndY = track->End().Y() + trackVertexEndOffset.Y();
  double trackVertexEndZ = track->End().Z() + trackVertexEndOffset.Z();

  std::cout<<"CHECK3 Vertex X: "<<vx<<" Track X start: "<<trackVertexX<<" end: "<<trackVertexEndX<<std::endl;
  std::cout<<"CHECK3 Vertex Y: "<<vy<<" Track Y start: "<<trackVertexY<<" end: "<<trackVertexEndY<<std::endl;
  std::cout<<"CHECK3 Vertex Z: "<<vz<<" Track Z start: "<<trackVertexZ<<" end: "<<trackVertexEndZ<<std::endl;
  
  
  double startdist = std::sqrt(std::pow(trackVertexX - vx,2) + std::pow(trackVertexY - vy,2) + std::pow(trackVertexZ - vz,2));
  double enddist = std::sqrt(std::pow(trackVertexEndX - vx,2) + std::pow(trackVertexEndY - vy,2) + std::pow(trackVertexEndZ - vz,2));
  double mindist = std::min(startdist,enddist);

  std::cout<<"CHECK3 Track start dist: "<<startdist<<" end dist: "<<enddist<<" min dist: "<<mindist<<std::endl;
    
  double tracklength = std::sqrt(std::pow(trackVertexX - trackVertexEndX,2) + std::pow(trackVertexY - trackVertexEndY,2) + std::pow(trackVertexZ - trackVertexEndZ,2));

  std::cout<<"CHECK3 Track length: "<<tracklength<<std::endl;
  
  double trackNearX = -999; double trackNearY = -999; double trackNearZ = -999;
  double trackFarX = -999; double trackFarY = -999; double trackFarZ = -999;
  if(mindist == startdist){
    trackNearX = trackVertexX;
    trackNearY = trackVertexY;
    trackNearZ = trackVertexZ;
    trackFarX = trackVertexEndX;
    trackFarY = trackVertexEndY;
    trackFarZ = trackVertexEndZ;
  }
  if(mindist == enddist){
    trackFarX = trackVertexX;
    trackFarY = trackVertexY;
    trackFarZ = trackVertexZ;
    trackNearX = trackVertexEndX;
    trackNearY = trackVertexEndY;
    trackNearZ = trackVertexEndZ;
  }

  std::cout<<"CHECK3 Track X near: "<<trackNearX<<" far: "<<trackFarX<<std::endl;
  std::cout<<"CHECK3 Track Y near: "<<trackNearY<<" far: "<<trackFarY<<std::endl;
  std::cout<<"CHECK3 Track Z near: "<<trackNearZ<<" far: "<<trackFarZ<<std::endl;

  if(inFV(trackNearX,trackNearY,trackNearZ) && inFV(trackFarX,trackFarY,trackFarZ)){
    std::cout<<"CHECK3 a vector: "<<trackNearX - vx<<" "<<trackNearY- vy<<" "<<trackFarZ - trackNearZ<<std::endl;
    std::cout<<"CHECK3 b vector: "<<trackFarX - trackNearX<<" "<<trackFarY- trackNearY<<" "<<trackNearZ - vz<<std::endl;
    double dotproduct = ((trackNearX - vx)*(trackFarX - trackNearX)) + ((trackNearY - vy)*(trackFarY - trackNearY)) + ((trackNearZ - vz)*(trackFarZ - trackNearZ));
    ang3d = dotproduct/(mindist*tracklength);
    std::cout<<"CHECK3 Track dotproduct: "<<dotproduct<<std::endl;
  }

  std::cout<<"CHECK3 Track ang3d: "<<ang3d<<std::endl;
   
  return ang3d;
}//trackRadialAngle

double CCpi0Tree::angleBetweenTwoShowers(art::Ptr<recob::Shower> shower1, art::Ptr<recob::Shower> shower2){

  //double angle = -9999999.;
  double cosangle = -9999999.;
  
  double dirx1 = shower1->Direction().X();
  double diry1 = shower1->Direction().Y();
  double dirz1 = shower1->Direction().Z();

  double dirx2 = shower2->Direction().X();
  double diry2 = shower2->Direction().Y();
  double dirz2 = shower2->Direction().Z();

  cosangle = (dirx1*dirx2) + (diry1*diry2) + (dirz1*dirz2);
  //angle = std::acos(cosangle);

  return cosangle;
}//angleBetweenTwoShowers

double CCpi0Tree::pi0Mass(double energy1, double energy2, double angle){

  double mass = -9999;
  mass = std::sqrt(2*energy1*energy2*(1 - angle));

  return mass;
 
}//pi0Mass

double CCpi0Tree::pi0Momentum(double mass, double energy1, double energy2, double angle){

  double momentum = -9999;
  double alpha = (std::abs(energy1 - energy2))/(energy1 + energy2);

  momentum = mass*std::sqrt(2/((1 - std::pow(alpha,2))*(1 - angle)));

  return momentum;
 
}//pi0Momentum

double CCpi0Tree::Altpi0Momentum(double energy1, double energy2, double angle){

  double momentum = -9999;

  momentum = std::sqrt(std::pow(energy1,2) + std::pow(energy2,2) + (2*energy1*energy2*angle));

  return momentum;
 
}//Altpi0Momentum

double CCpi0Tree::pi0Angle(double p, double energy1, double energy2, art::Ptr<recob::Shower> gamma1, art::Ptr<recob::Shower> gamma2){

  double dirz1 = gamma1->Direction().Z();
  double dirz2 = gamma2->Direction().Z();

  double pi0costheta = ((energy1*dirz1) + (energy2*dirz2))/p;

  return pi0costheta;

}//pi0Angle

double CCpi0Tree::pi0Phi(double energy1, double energy2, art::Ptr<recob::Shower> gamma1, art::Ptr<recob::Shower> gamma2){

  double dirx1 = gamma1->Direction().X();
  double diry1 = gamma1->Direction().Y();
  
  double dirx2 = gamma2->Direction().X();
  double diry2 = gamma2->Direction().Y();

  double pi0phi = std::atan(((energy1*diry1) + (energy2*diry2))/((energy1*dirx1) + (energy2*dirx2)));

  return pi0phi;

}//pi0Phi

double CCpi0Tree::pi0MomentumBias(double true_p, double reco_p){

  double bias = -999;
  if(true_p != 0){bias = (true_p - reco_p)/true_p;}
  return bias;

}//pi0MomentumBias


double CCpi0Tree::pi0AngleBias(double true_px, double true_py, double true_pz, double true_p, double reco_p, double reco_energy1, double reco_energy2, art::Ptr<recob::Shower> gamma1, art::Ptr<recob::Shower> gamma2){

  double anglebias = -999;

  double dirx1 = gamma1->Direction().X();
  double diry1 = gamma1->Direction().Y();
  double dirz1 = gamma1->Direction().Z();
  
  double dirx2 = gamma2->Direction().X();
  double diry2 = gamma2->Direction().Y();
  double dirz2 = gamma2->Direction().Z();

  double reco_px = (reco_energy1*dirx1) + (reco_energy2*dirx2);
  double reco_py = (reco_energy1*diry1) + (reco_energy2*diry2);
  double reco_pz = (reco_energy1*dirz1) + (reco_energy2*dirz2);

  double dotproduct = (true_px*reco_px) + (true_py*reco_py) + (true_pz*reco_pz);
  anglebias = dotproduct/(true_p*reco_p);
  
  return anglebias;

}//pi0AngleBiasCosine

double CCpi0Tree::muonMomentumBias(double true_p, double reco_p){

  double bias = -999;
  if(true_p != 0){bias = (true_p - reco_p)/true_p;}
  return bias;

}//muonMomentumBias


double CCpi0Tree::muonAngleBias(double vx, double vy, double vz, double true_px, double true_py, double true_pz, double true_p, double reco_p, art::Ptr<recob::Track> muon){

  double anglebias = -999;
  
  auto muonVertexOffset = SCE->GetCalPosOffsets(geo::Point_t(muon->Vertex().X(), muon->Vertex().Y(), muon->Vertex().Z()));
  auto muonVertexEndOffset = SCE->GetCalPosOffsets(geo::Point_t(muon->End().X(), muon->End().Y(), muon->End().Z()));
  
  double muonVertexX = muon->Vertex().X() - muonVertexOffset.X();
  double muonVertexY = muon->Vertex().Y() + muonVertexOffset.Y();
  double muonVertexZ = muon->Vertex().Z() + muonVertexOffset.Z();
  double muonVertexEndX = muon->End().X() - muonVertexEndOffset.X();
  double muonVertexEndY = muon->End().Y() + muonVertexEndOffset.Y();
  double muonVertexEndZ = muon->End().Z() + muonVertexEndOffset.Z();

  double startdist = std::sqrt(std::pow(muonVertexX - vx,2) + std::pow(muonVertexY - vy,2) + std::pow(muonVertexZ - vz,2));
  double enddist = std::sqrt(std::pow(muonVertexEndX - vx,2) + std::pow(muonVertexEndY - vy,2) + std::pow(muonVertexEndZ - vz,2));
 
  double dirx = -999; double diry = -999; double dirz = -999;
  if(startdist <= enddist){
    dirx = muon->VertexDirection().X();
    diry = muon->VertexDirection().Y();
    dirz = muon->VertexDirection().Z();
  }
  if(startdist > enddist){
    dirx = muon->EndDirection().X();
    diry = muon->EndDirection().Y();
    dirz = muon->EndDirection().Z();
  }
 
  double reco_px = reco_p*dirx;
  double reco_py = reco_p*diry;
  double reco_pz = reco_p*dirz;

  double dotproduct = (true_px*reco_px) + (true_py*reco_py) + (true_pz*reco_pz);
  anglebias = dotproduct/(true_p*reco_p);

  return anglebias;

}//muonAngleBiasCosine

double CCpi0Tree::GammaAngleBias(int mcparticleid, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, double Gamma1_E, double Gamma2_E, double Gamma1_DirX, double Gamma1_DirY, double Gamma1_DirZ, double Gamma2_DirX, double Gamma2_DirY, double Gamma2_DirZ, double reco_energy, art::Ptr<recob::Shower> reco_gamma){

  double anglebias = -999;

  double recodirx = reco_gamma->Direction().X();
  double recodiry = reco_gamma->Direction().Y();
  double recodirz = reco_gamma->Direction().Z();
  
  double reco_px = reco_energy*recodirx;
  double reco_py = reco_energy*recodiry;
  double reco_pz = reco_energy*recodirz;

  double true_px = -999;
  double true_py = -999;
  double true_pz = -999;
  double true_p = -999;

  int momid = -999;
  for(auto const& mcpart : all_mcparticles){
    if(mcparticleid == mcpart->TrackId()){
      momid = mcpart->Mother();
    }
  }//mcparticle loop

  //matches to gamma1
  if(momid == Gamma1_id){
    true_px = Gamma1_E*Gamma1_DirX;
    true_py = Gamma1_E*Gamma1_DirY;
    true_pz = Gamma1_E*Gamma1_DirZ;
    true_p = Gamma1_E;
  }//g1

  //matches to gamma2
  if(momid == Gamma2_id){
    true_px = Gamma2_E*Gamma2_DirX;
    true_py = Gamma2_E*Gamma2_DirY;
    true_pz = Gamma2_E*Gamma2_DirZ;
    true_p = Gamma2_E;
  }//g2

  double dotproduct = (true_px*reco_px) + (true_py*reco_py) + (true_pz*reco_pz);
  anglebias = dotproduct/(true_p*reco_energy);
  
  return anglebias;

}//GammaAngleBias


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CCpi0Tree::endSubRun(art::SubRun const & sr) {

  art::Handle <sumdata::POTSummary> potsum_h ;
  if(sr.getByLabel("generator",potsum_h)){
    if(fIsMC || fIsDirt){
      _pot = potsum_h->totpot;
    }
  }
  
  if(!fIsMC && !fIsDirt){
    _run = sr.run();
    _subRun = sr.subRun();
  }
  _tree->Fill();

  
}//endSubRun


void CCpi0Tree::endJob(){

  mf::LogVerbatim("CCpi0Tree")<< "CCpi0Tree finished job";
				 
																								 
}//endJob


DEFINE_ART_MODULE(CCpi0Tree)
